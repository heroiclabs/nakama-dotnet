\hypertarget{interface_nakama_1_1_console_1_1_i_protobuf_any}{}\doxysection{Nakama.\+Console.\+IProtobuf\+Any Interface Reference}
\label{interface_nakama_1_1_console_1_1_i_protobuf_any}\index{Nakama.Console.IProtobufAny@{Nakama.Console.IProtobufAny}}


{\ttfamily Any} contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1\+: Pack and unpack a message in C++. Foo foo = ...; Any any; any.\+Pack\+From(foo); ... if (any.\+Unpack\+To(\&foo)) \{ ... \} Example 2\+: Pack and unpack a message in Java. Foo foo = ...; Any any = Any.\+pack(foo); ... if (any.\+is(Foo.\+class)) \{ foo = any.\+unpack(Foo.\+class); \} Example 3\+: Pack and unpack a message in Python. foo = Foo(...) any = Any() any.\+Pack(foo) ... if any.\+Is(Foo.\+DESCRIPTOR)\+: any.\+Unpack(foo) ... Example 4\+: Pack and unpack a message in Go foo \+:= \&pb.\+Foo\{...\} any, err \+:= ptypes.\+Marshal\+Any(foo) ... foo \+:= \&pb.\+Foo\{\} if err \+:= ptypes.\+Unmarshal\+Any(any, foo); err != nil \{ ... \} The pack methods provided by protobuf library will by default use \textquotesingle{}type.\+googleapis.\+com/full.type.\+name\textquotesingle{} as the type URL and the unpack methods only use the fully qualified type name after the last \textquotesingle{}/\textquotesingle{} in the type URL, for example \char`\"{}foo.\+bar.\+com/x/y.\+z\char`\"{} will yield type name \char`\"{}y.\+z\char`\"{}. JSON ==== The JSON representation of an {\ttfamily Any} value uses the regular representation of the deserialized, embedded message, with an additional field {\ttfamily @type} which contains the type URL. Example\+: package google.\+profile; message Person \{ string first\+\_\+name = 1; string last\+\_\+name = 2; \} \{ \char`\"{}@type\char`\"{}\+: \char`\"{}type.\+googleapis.\+com/google.\+profile.\+Person\char`\"{}, \char`\"{}first\+Name\char`\"{}\+: $<$string$>$, \char`\"{}last\+Name\char`\"{}\+: $<$string$>$ \} If the embedded message type is well-\/known and has a custom JSON representation, that representation will be embedded adding a field {\ttfamily value} which holds the custom JSON in addition to the {\ttfamily @type} field. Example (for message \mbox{[}google.\+protobuf.\+Duration\mbox{]}\mbox{[}\mbox{]})\+: \{ \char`\"{}@type\char`\"{}\+: \char`\"{}type.\+googleapis.\+com/google.\+protobuf.\+Duration\char`\"{}, \char`\"{}value\char`\"{}\+: \char`\"{}1.\+212s\char`\"{} \}   




Inherited by Nakama.\+Console.\+Protobuf\+Any.

\doxysubsection*{Properties}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{interface_nakama_1_1_console_1_1_i_protobuf_any_a9729b3262d0481a8510ec54901fecb4a}\label{interface_nakama_1_1_console_1_1_i_protobuf_any_a9729b3262d0481a8510ec54901fecb4a}} 
string {\bfseries Type\+Url}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \char`\"{}/\char`\"{} character. The last segment of the URL\textquotesingle{}s path must represent the fully qualified name of the type (as in {\ttfamily path/google.\+protobuf.\+Duration}). The name should be in a canonical form (e.\+g., leading \char`\"{}.\char`\"{} is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme {\ttfamily http}, {\ttfamily https}, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows\+: $\ast$ If no scheme is provided, {\ttfamily https} is assumed. $\ast$ An HTTP GET on the URL must yield a \mbox{[}google.\+protobuf.\+Type\mbox{]}\mbox{[}\mbox{]} value in binary format, or produce an error. $\ast$ Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Note\+: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.\+googleapis.\+com. Schemes other than {\ttfamily http}, {\ttfamily https} (or the empty scheme) might be used with implementation specific semantics.  \end{DoxyCompactList}\item 
\mbox{\Hypertarget{interface_nakama_1_1_console_1_1_i_protobuf_any_a382dcf0d9d31a6e039d743ec74cabbcc}\label{interface_nakama_1_1_console_1_1_i_protobuf_any_a382dcf0d9d31a6e039d743ec74cabbcc}} 
string {\bfseries Value}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Must be a valid serialized protocol buffer of the above specified type.  \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
{\ttfamily Any} contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1\+: Pack and unpack a message in C++. Foo foo = ...; Any any; any.\+Pack\+From(foo); ... if (any.\+Unpack\+To(\&foo)) \{ ... \} Example 2\+: Pack and unpack a message in Java. Foo foo = ...; Any any = Any.\+pack(foo); ... if (any.\+is(Foo.\+class)) \{ foo = any.\+unpack(Foo.\+class); \} Example 3\+: Pack and unpack a message in Python. foo = Foo(...) any = Any() any.\+Pack(foo) ... if any.\+Is(Foo.\+DESCRIPTOR)\+: any.\+Unpack(foo) ... Example 4\+: Pack and unpack a message in Go foo \+:= \&pb.\+Foo\{...\} any, err \+:= ptypes.\+Marshal\+Any(foo) ... foo \+:= \&pb.\+Foo\{\} if err \+:= ptypes.\+Unmarshal\+Any(any, foo); err != nil \{ ... \} The pack methods provided by protobuf library will by default use \textquotesingle{}type.\+googleapis.\+com/full.type.\+name\textquotesingle{} as the type URL and the unpack methods only use the fully qualified type name after the last \textquotesingle{}/\textquotesingle{} in the type URL, for example \char`\"{}foo.\+bar.\+com/x/y.\+z\char`\"{} will yield type name \char`\"{}y.\+z\char`\"{}. JSON ==== The JSON representation of an {\ttfamily Any} value uses the regular representation of the deserialized, embedded message, with an additional field {\ttfamily @type} which contains the type URL. Example\+: package google.\+profile; message Person \{ string first\+\_\+name = 1; string last\+\_\+name = 2; \} \{ \char`\"{}@type\char`\"{}\+: \char`\"{}type.\+googleapis.\+com/google.\+profile.\+Person\char`\"{}, \char`\"{}first\+Name\char`\"{}\+: $<$string$>$, \char`\"{}last\+Name\char`\"{}\+: $<$string$>$ \} If the embedded message type is well-\/known and has a custom JSON representation, that representation will be embedded adding a field {\ttfamily value} which holds the custom JSON in addition to the {\ttfamily @type} field. Example (for message \mbox{[}google.\+protobuf.\+Duration\mbox{]}\mbox{[}\mbox{]})\+: \{ \char`\"{}@type\char`\"{}\+: \char`\"{}type.\+googleapis.\+com/google.\+protobuf.\+Duration\char`\"{}, \char`\"{}value\char`\"{}\+: \char`\"{}1.\+212s\char`\"{} \}  

The documentation for this interface was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Nakama/\+Console/Console\+Client.\+gen.\+cs\end{DoxyCompactItemize}
