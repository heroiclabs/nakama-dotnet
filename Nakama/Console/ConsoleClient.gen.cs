/* Code generated by codegen/main.go. DO NOT EDIT. */
namespace Nakama.Console
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;
    using TinyJson;

    /// <summary>
    /// An exception generated for <c>HttpResponse</c> objects don't return a success status.
    /// </summary>
    public sealed class ApiResponseException : Exception
    {
        public long StatusCode { get; }

        public int GrpcStatusCode { get; }

        public ApiResponseException(long statusCode, string content, int grpcCode) : base(content)
        {
            StatusCode = statusCode;
            GrpcStatusCode = grpcCode;
        }

        public ApiResponseException(string message, Exception e) : base(message, e)
        {
            StatusCode = -1L;
            GrpcStatusCode = -1;
        }

        public ApiResponseException(string content) : this(-1L, content, -1)
        {
        }

        public override string ToString()
        {
            return $"ApiResponseException(StatusCode={StatusCode}, Message='{Message}', GrpcStatusCode={GrpcStatusCode})";
        }
    }

    /// <summary>
    /// Write a new storage object or update an existing one.
    /// </summary>
    public interface IApiConsole_WriteStorageObjectRequest
    {

        /// <summary>
        /// Read permission value.
        /// </summary>
        int PermissionRead { get; }

        /// <summary>
        /// Write permission value.
        /// </summary>
        int PermissionWrite { get; }

        /// <summary>
        /// Value.
        /// </summary>
        string Value { get; }

        /// <summary>
        /// Version for OCC.
        /// </summary>
        string Version { get; }
    }

    /// <inheritdoc />
    internal class ApiConsole_WriteStorageObjectRequest : IApiConsole_WriteStorageObjectRequest
    {

        /// <inheritdoc />
        [DataMember(Name="permission_read"), Preserve]
        public int PermissionRead { get; set; }

        /// <inheritdoc />
        [DataMember(Name="permission_write"), Preserve]
        public int PermissionWrite { get; set; }

        /// <inheritdoc />
        [DataMember(Name="value"), Preserve]
        public string Value { get; set; }

        /// <inheritdoc />
        [DataMember(Name="version"), Preserve]
        public string Version { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "PermissionRead: ", PermissionRead, ", ");
            output = string.Concat(output, "PermissionWrite: ", PermissionWrite, ", ");
            output = string.Concat(output, "Value: ", Value, ", ");
            output = string.Concat(output, "Version: ", Version, ", ");
            return output;
        }
    }

    /// <summary>
    /// A warning for a configuration field.
    /// </summary>
    public interface IConfigWarning
    {

        /// <summary>
        /// The config field this warning is for in a JSON pointer format.
        /// </summary>
        string Field { get; }

        /// <summary>
        /// Warning message text.
        /// </summary>
        string Message { get; }
    }

    /// <inheritdoc />
    internal class ConfigWarning : IConfigWarning
    {

        /// <inheritdoc />
        [DataMember(Name="field"), Preserve]
        public string Field { get; set; }

        /// <inheritdoc />
        [DataMember(Name="message"), Preserve]
        public string Message { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Field: ", Field, ", ");
            output = string.Concat(output, "Message: ", Message, ", ");
            return output;
        }
    }

    /// <summary>
    /// A single user-role pair.
    /// </summary>
    public interface IGroupUserListGroupUser
    {

        /// <summary>
        /// Their relationship to the group.
        /// </summary>
        int State { get; }

        /// <summary>
        /// User.
        /// </summary>
        INakamaapiUser User { get; }
    }

    /// <inheritdoc />
    internal class GroupUserListGroupUser : IGroupUserListGroupUser
    {

        /// <inheritdoc />
        [DataMember(Name="state"), Preserve]
        public int State { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public INakamaapiUser User => _user;
        [DataMember(Name="user"), Preserve]
        public NakamaapiUser _user { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "State: ", State, ", ");
            output = string.Concat(output, "User: ", User, ", ");
            return output;
        }
    }

    /// <summary>
    /// Module information
    /// </summary>
    public interface IRuntimeInfoModuleInfo
    {

        /// <summary>
        /// Module last modified date
        /// </summary>
        string ModTime { get; }

        /// <summary>
        /// Module path
        /// </summary>
        string Path { get; }
    }

    /// <inheritdoc />
    internal class RuntimeInfoModuleInfo : IRuntimeInfoModuleInfo
    {

        /// <inheritdoc />
        [DataMember(Name="mod_time"), Preserve]
        public string ModTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="path"), Preserve]
        public string Path { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "ModTime: ", ModTime, ", ");
            output = string.Concat(output, "Path: ", Path, ", ");
            return output;
        }
    }

    /// <summary>
    /// A single group-role pair.
    /// </summary>
    public interface IUserGroupListUserGroup
    {

        /// <summary>
        /// Group.
        /// </summary>
        IApiGroup Group { get; }

        /// <summary>
        /// The user's relationship to the group.
        /// </summary>
        int State { get; }
    }

    /// <inheritdoc />
    internal class UserGroupListUserGroup : IUserGroupListUserGroup
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IApiGroup Group => _group;
        [DataMember(Name="group"), Preserve]
        public ApiGroup _group { get; set; }

        /// <inheritdoc />
        [DataMember(Name="state"), Preserve]
        public int State { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Group: ", Group, ", ");
            output = string.Concat(output, "State: ", State, ", ");
            return output;
        }
    }

    /// <summary>
    /// Send a device to the server. Used with authenticate/link/unlink and user.
    /// </summary>
    public interface IApiAccountDevice
    {

        /// <summary>
        /// A device identifier. Should be obtained by a platform-specific device API.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// Extra information that will be bundled in the session token.
        /// </summary>
        IDictionary<string, string> Vars { get; }
    }

    /// <inheritdoc />
    internal class ApiAccountDevice : IApiAccountDevice
    {

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IDictionary<string, string> Vars => _vars ?? new Dictionary<string, string>();
        [DataMember(Name="vars"), Preserve]
        public Dictionary<string, string> _vars { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Id: ", Id, ", ");

            var varsString = "";
            foreach (var kvp in Vars)
            {
                varsString = string.Concat(varsString, "{" + kvp.Key + "=" + kvp.Value + "}");
            }
            output = string.Concat(output, "Vars: [" + varsString + "]");
            return output;
        }
    }

    /// <summary>
    /// A message sent on a channel.
    /// </summary>
    public interface IApiChannelMessage
    {

        /// <summary>
        /// The channel this message belongs to.
        /// </summary>
        string ChannelId { get; }

        /// <summary>
        /// The code representing a message type or category.
        /// </summary>
        int Code { get; }

        /// <summary>
        /// The content payload.
        /// </summary>
        string Content { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The ID of the group, or an empty string if this message was not sent through a group channel.
        /// </summary>
        string GroupId { get; }

        /// <summary>
        /// The unique ID of this message.
        /// </summary>
        string MessageId { get; }

        /// <summary>
        /// True if the message was persisted to the channel's history, false otherwise.
        /// </summary>
        bool Persistent { get; }

        /// <summary>
        /// The name of the chat room, or an empty string if this message was not sent through a chat room.
        /// </summary>
        string RoomName { get; }

        /// <summary>
        /// Message sender, usually a user ID.
        /// </summary>
        string SenderId { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
        /// </summary>
        string UserIdOne { get; }

        /// <summary>
        /// The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
        /// </summary>
        string UserIdTwo { get; }

        /// <summary>
        /// The username of the message sender, if any.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class ApiChannelMessage : IApiChannelMessage
    {

        /// <inheritdoc />
        [DataMember(Name="channel_id"), Preserve]
        public string ChannelId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="code"), Preserve]
        public int Code { get; set; }

        /// <inheritdoc />
        [DataMember(Name="content"), Preserve]
        public string Content { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="group_id"), Preserve]
        public string GroupId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="message_id"), Preserve]
        public string MessageId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="persistent"), Preserve]
        public bool Persistent { get; set; }

        /// <inheritdoc />
        [DataMember(Name="room_name"), Preserve]
        public string RoomName { get; set; }

        /// <inheritdoc />
        [DataMember(Name="sender_id"), Preserve]
        public string SenderId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id_one"), Preserve]
        public string UserIdOne { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id_two"), Preserve]
        public string UserIdTwo { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "ChannelId: ", ChannelId, ", ");
            output = string.Concat(output, "Code: ", Code, ", ");
            output = string.Concat(output, "Content: ", Content, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "GroupId: ", GroupId, ", ");
            output = string.Concat(output, "MessageId: ", MessageId, ", ");
            output = string.Concat(output, "Persistent: ", Persistent, ", ");
            output = string.Concat(output, "RoomName: ", RoomName, ", ");
            output = string.Concat(output, "SenderId: ", SenderId, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "UserIdOne: ", UserIdOne, ", ");
            output = string.Concat(output, "UserIdTwo: ", UserIdTwo, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of channel messages, usually a result of a list operation.
    /// </summary>
    public interface IApiChannelMessageList
    {

        /// <summary>
        /// Cacheable cursor to list newer messages. Durable and designed to be stored, unlike next/prev cursors.
        /// </summary>
        string CacheableCursor { get; }

        /// <summary>
        /// A list of messages.
        /// </summary>
        IEnumerable<IApiChannelMessage> Messages { get; }

        /// <summary>
        /// The cursor to send when retrieving the next page, if any.
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// The cursor to send when retrieving the previous page, if any.
        /// </summary>
        string PrevCursor { get; }
    }

    /// <inheritdoc />
    internal class ApiChannelMessageList : IApiChannelMessageList
    {

        /// <inheritdoc />
        [DataMember(Name="cacheable_cursor"), Preserve]
        public string CacheableCursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiChannelMessage> Messages => _messages ?? new List<ApiChannelMessage>(0);
        [DataMember(Name="messages"), Preserve]
        public List<ApiChannelMessage> _messages { get; set; }

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_cursor"), Preserve]
        public string PrevCursor { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "CacheableCursor: ", CacheableCursor, ", ");
            output = string.Concat(output, "Messages: [", string.Join(", ", Messages), "], ");
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "PrevCursor: ", PrevCursor, ", ");
            return output;
        }
    }

    /// <summary>
    /// A friend of a user.
    /// </summary>
    public interface IApiFriend
    {

        /// <summary>
        /// Metadata.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The friend status.  one of "Friend.State".
        /// </summary>
        int State { get; }

        /// <summary>
        /// Time of the latest relationship update.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The user object.
        /// </summary>
        INakamaapiUser User { get; }
    }

    /// <inheritdoc />
    internal class ApiFriend : IApiFriend
    {

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="state"), Preserve]
        public int State { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public INakamaapiUser User => _user;
        [DataMember(Name="user"), Preserve]
        public NakamaapiUser _user { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "State: ", State, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "User: ", User, ", ");
            return output;
        }
    }

    /// <summary>
    /// A collection of zero or more friends of the user.
    /// </summary>
    public interface IApiFriendList
    {

        /// <summary>
        /// Cursor for the next page of results, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// The Friend objects.
        /// </summary>
        IEnumerable<IApiFriend> Friends { get; }
    }

    /// <inheritdoc />
    internal class ApiFriendList : IApiFriendList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiFriend> Friends => _friends ?? new List<ApiFriend>(0);
        [DataMember(Name="friends"), Preserve]
        public List<ApiFriend> _friends { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "Friends: [", string.Join(", ", Friends), "], ");
            return output;
        }
    }

    /// <summary>
    /// A group in the server.
    /// </summary>
    public interface IApiGroup
    {

        /// <summary>
        /// A URL for an avatar image.
        /// </summary>
        string AvatarUrl { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The id of the user who created the group.
        /// </summary>
        string CreatorId { get; }

        /// <summary>
        /// A description for the group.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// The current count of all members in the group.
        /// </summary>
        int EdgeCount { get; }

        /// <summary>
        /// The id of a group.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// The language expected to be a tag which follows the BCP-47 spec.
        /// </summary>
        string LangTag { get; }

        /// <summary>
        /// The maximum number of members allowed.
        /// </summary>
        int MaxCount { get; }

        /// <summary>
        /// Additional information stored as a JSON object.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The unique name of the group.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Anyone can join open groups, otherwise only admins can accept members.
        /// </summary>
        bool Open { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was last updated.
        /// </summary>
        string UpdateTime { get; }
    }

    /// <inheritdoc />
    internal class ApiGroup : IApiGroup
    {

        /// <inheritdoc />
        [DataMember(Name="avatar_url"), Preserve]
        public string AvatarUrl { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="creator_id"), Preserve]
        public string CreatorId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="description"), Preserve]
        public string Description { get; set; }

        /// <inheritdoc />
        [DataMember(Name="edge_count"), Preserve]
        public int EdgeCount { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="lang_tag"), Preserve]
        public string LangTag { get; set; }

        /// <inheritdoc />
        [DataMember(Name="max_count"), Preserve]
        public int MaxCount { get; set; }

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="name"), Preserve]
        public string Name { get; set; }

        /// <inheritdoc />
        [DataMember(Name="open"), Preserve]
        public bool Open { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "AvatarUrl: ", AvatarUrl, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "CreatorId: ", CreatorId, ", ");
            output = string.Concat(output, "Description: ", Description, ", ");
            output = string.Concat(output, "EdgeCount: ", EdgeCount, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "LangTag: ", LangTag, ", ");
            output = string.Concat(output, "MaxCount: ", MaxCount, ", ");
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "Name: ", Name, ", ");
            output = string.Concat(output, "Open: ", Open, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of users belonging to a group, along with their role.
    /// </summary>
    public interface IApiGroupUserList
    {

        /// <summary>
        /// Cursor for the next page of results, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// User-role pairs for a group.
        /// </summary>
        IEnumerable<IGroupUserListGroupUser> GroupUsers { get; }
    }

    /// <inheritdoc />
    internal class ApiGroupUserList : IApiGroupUserList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IGroupUserListGroupUser> GroupUsers => _groupUsers ?? new List<GroupUserListGroupUser>(0);
        [DataMember(Name="group_users"), Preserve]
        public List<GroupUserListGroupUser> _groupUsers { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "GroupUsers: [", string.Join(", ", GroupUsers), "], ");
            return output;
        }
    }

    /// <summary>
    /// Represents a complete leaderboard record with all scores and associated metadata.
    /// </summary>
    public interface IApiLeaderboardRecord
    {

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the leaderboard record was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the leaderboard record expires.
        /// </summary>
        string ExpiryTime { get; }

        /// <summary>
        /// The ID of the leaderboard this score belongs to.
        /// </summary>
        string LeaderboardId { get; }

        /// <summary>
        /// The maximum number of score updates allowed by the owner.
        /// </summary>
        int MaxNumScore { get; }

        /// <summary>
        /// Metadata.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The number of submissions to this score record.
        /// </summary>
        int NumScore { get; }

        /// <summary>
        /// The ID of the score owner, usually a user or group.
        /// </summary>
        string OwnerId { get; }

        /// <summary>
        /// The rank of this record.
        /// </summary>
        string Rank { get; }

        /// <summary>
        /// The score value.
        /// </summary>
        string Score { get; }

        /// <summary>
        /// An optional subscore value.
        /// </summary>
        string Subscore { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the leaderboard record was updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The username of the score owner, if the owner is a user.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class ApiLeaderboardRecord : IApiLeaderboardRecord
    {

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="expiry_time"), Preserve]
        public string ExpiryTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="leaderboard_id"), Preserve]
        public string LeaderboardId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="max_num_score"), Preserve]
        public int MaxNumScore { get; set; }

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="num_score"), Preserve]
        public int NumScore { get; set; }

        /// <inheritdoc />
        [DataMember(Name="owner_id"), Preserve]
        public string OwnerId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="rank"), Preserve]
        public string Rank { get; set; }

        /// <inheritdoc />
        [DataMember(Name="score"), Preserve]
        public string Score { get; set; }

        /// <inheritdoc />
        [DataMember(Name="subscore"), Preserve]
        public string Subscore { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "ExpiryTime: ", ExpiryTime, ", ");
            output = string.Concat(output, "LeaderboardId: ", LeaderboardId, ", ");
            output = string.Concat(output, "MaxNumScore: ", MaxNumScore, ", ");
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "NumScore: ", NumScore, ", ");
            output = string.Concat(output, "OwnerId: ", OwnerId, ", ");
            output = string.Concat(output, "Rank: ", Rank, ", ");
            output = string.Concat(output, "Score: ", Score, ", ");
            output = string.Concat(output, "Subscore: ", Subscore, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
    /// </summary>
    public interface IApiLeaderboardRecordList
    {

        /// <summary>
        /// The cursor to send when retrieving the next page, if any.
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// A batched set of leaderboard records belonging to specified owners.
        /// </summary>
        IEnumerable<IApiLeaderboardRecord> OwnerRecords { get; }

        /// <summary>
        /// The cursor to send when retrieving the previous page, if any.
        /// </summary>
        string PrevCursor { get; }

        /// <summary>
        /// The total number of ranks available.
        /// </summary>
        string RankCount { get; }

        /// <summary>
        /// A list of leaderboard records.
        /// </summary>
        IEnumerable<IApiLeaderboardRecord> Records { get; }
    }

    /// <inheritdoc />
    internal class ApiLeaderboardRecordList : IApiLeaderboardRecordList
    {

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiLeaderboardRecord> OwnerRecords => _ownerRecords ?? new List<ApiLeaderboardRecord>(0);
        [DataMember(Name="owner_records"), Preserve]
        public List<ApiLeaderboardRecord> _ownerRecords { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_cursor"), Preserve]
        public string PrevCursor { get; set; }

        /// <inheritdoc />
        [DataMember(Name="rank_count"), Preserve]
        public string RankCount { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiLeaderboardRecord> Records => _records ?? new List<ApiLeaderboardRecord>(0);
        [DataMember(Name="records"), Preserve]
        public List<ApiLeaderboardRecord> _records { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "OwnerRecords: [", string.Join(", ", OwnerRecords), "], ");
            output = string.Concat(output, "PrevCursor: ", PrevCursor, ", ");
            output = string.Concat(output, "RankCount: ", RankCount, ", ");
            output = string.Concat(output, "Records: [", string.Join(", ", Records), "], ");
            return output;
        }
    }

    /// <summary>
    /// A list of validated purchases stored by Nakama.
    /// </summary>
    public interface IApiPurchaseList
    {

        /// <summary>
        /// The cursor to send when retrieving the next page, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// The cursor to send when retrieving the previous page, if any.
        /// </summary>
        string PrevCursor { get; }

        /// <summary>
        /// Stored validated purchases.
        /// </summary>
        IEnumerable<IApiValidatedPurchase> ValidatedPurchases { get; }
    }

    /// <inheritdoc />
    internal class ApiPurchaseList : IApiPurchaseList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_cursor"), Preserve]
        public string PrevCursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiValidatedPurchase> ValidatedPurchases => _validatedPurchases ?? new List<ApiValidatedPurchase>(0);
        [DataMember(Name="validated_purchases"), Preserve]
        public List<ApiValidatedPurchase> _validatedPurchases { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "PrevCursor: ", PrevCursor, ", ");
            output = string.Concat(output, "ValidatedPurchases: [", string.Join(", ", ValidatedPurchases), "], ");
            return output;
        }
    }

    /// <summary>
    /// An object within the storage engine.
    /// </summary>
    public interface IApiStorageObject
    {

        /// <summary>
        /// The collection which stores the object.
        /// </summary>
        string Collection { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The key of the object within the collection.
        /// </summary>
        string Key { get; }

        /// <summary>
        /// The read access permissions for the object.
        /// </summary>
        int PermissionRead { get; }

        /// <summary>
        /// The write access permissions for the object.
        /// </summary>
        int PermissionWrite { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was last updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The user owner of the object.
        /// </summary>
        string UserId { get; }

        /// <summary>
        /// The value of the object.
        /// </summary>
        string Value { get; }

        /// <summary>
        /// The version hash of the object.
        /// </summary>
        string Version { get; }
    }

    /// <inheritdoc />
    internal class ApiStorageObject : IApiStorageObject
    {

        /// <inheritdoc />
        [DataMember(Name="collection"), Preserve]
        public string Collection { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="key"), Preserve]
        public string Key { get; set; }

        /// <inheritdoc />
        [DataMember(Name="permission_read"), Preserve]
        public int PermissionRead { get; set; }

        /// <inheritdoc />
        [DataMember(Name="permission_write"), Preserve]
        public int PermissionWrite { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="value"), Preserve]
        public string Value { get; set; }

        /// <inheritdoc />
        [DataMember(Name="version"), Preserve]
        public string Version { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Collection: ", Collection, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Key: ", Key, ", ");
            output = string.Concat(output, "PermissionRead: ", PermissionRead, ", ");
            output = string.Concat(output, "PermissionWrite: ", PermissionWrite, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            output = string.Concat(output, "Value: ", Value, ", ");
            output = string.Concat(output, "Version: ", Version, ", ");
            return output;
        }
    }

    /// <summary>
    /// A storage acknowledgement.
    /// </summary>
    public interface IApiStorageObjectAck
    {

        /// <summary>
        /// The collection which stores the object.
        /// </summary>
        string Collection { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The key of the object within the collection.
        /// </summary>
        string Key { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was last updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The owner of the object.
        /// </summary>
        string UserId { get; }

        /// <summary>
        /// The version hash of the object.
        /// </summary>
        string Version { get; }
    }

    /// <inheritdoc />
    internal class ApiStorageObjectAck : IApiStorageObjectAck
    {

        /// <inheritdoc />
        [DataMember(Name="collection"), Preserve]
        public string Collection { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="key"), Preserve]
        public string Key { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="version"), Preserve]
        public string Version { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Collection: ", Collection, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Key: ", Key, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            output = string.Concat(output, "Version: ", Version, ", ");
            return output;
        }
    }

    /// <summary>
    /// Environment where a purchase/subscription took place,
    /// </summary>
    public enum ApiStoreEnvironment
    {
        /// <summary>
        /// - UNKNOWN: Unknown environment.
        /// </summary>
        UNKNOWN = 0,
        /// <summary>
        ///  - SANDBOX: Sandbox/test environment.
        /// </summary>
        SANDBOX = 1,
        /// <summary>
        ///  - PRODUCTION: Production environment.
        /// </summary>
        PRODUCTION = 2,
    }

    /// <summary>
    /// Validation Provider,
    /// </summary>
    public enum ApiStoreProvider
    {
        /// <summary>
        /// - APPLE_APP_STORE: Apple App Store
        /// </summary>
        APPLE_APP_STORE = 0,
        /// <summary>
        ///  - GOOGLE_PLAY_STORE: Google Play Store
        /// </summary>
        GOOGLE_PLAY_STORE = 1,
        /// <summary>
        ///  - HUAWEI_APP_GALLERY: Huawei App Gallery
        /// </summary>
        HUAWEI_APP_GALLERY = 2,
        /// <summary>
        ///  - FACEBOOK_INSTANT_STORE: Facebook Instant Store
        /// </summary>
        FACEBOOK_INSTANT_STORE = 3,
    }

    /// <summary>
    /// A list of validated subscriptions stored by Nakama.
    /// </summary>
    public interface IApiSubscriptionList
    {

        /// <summary>
        /// The cursor to send when retrieving the next page, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// The cursor to send when retrieving the previous page, if any.
        /// </summary>
        string PrevCursor { get; }

        /// <summary>
        /// Stored validated subscriptions.
        /// </summary>
        IEnumerable<IApiValidatedSubscription> ValidatedSubscriptions { get; }
    }

    /// <inheritdoc />
    internal class ApiSubscriptionList : IApiSubscriptionList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_cursor"), Preserve]
        public string PrevCursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiValidatedSubscription> ValidatedSubscriptions => _validatedSubscriptions ?? new List<ApiValidatedSubscription>(0);
        [DataMember(Name="validated_subscriptions"), Preserve]
        public List<ApiValidatedSubscription> _validatedSubscriptions { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "PrevCursor: ", PrevCursor, ", ");
            output = string.Concat(output, "ValidatedSubscriptions: [", string.Join(", ", ValidatedSubscriptions), "], ");
            return output;
        }
    }

    /// <summary>
    /// A list of groups belonging to a user, along with the user's role in each group.
    /// </summary>
    public interface IApiUserGroupList
    {

        /// <summary>
        /// Cursor for the next page of results, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// Group-role pairs for a user.
        /// </summary>
        IEnumerable<IUserGroupListUserGroup> UserGroups { get; }
    }

    /// <inheritdoc />
    internal class ApiUserGroupList : IApiUserGroupList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IUserGroupListUserGroup> UserGroups => _userGroups ?? new List<UserGroupListUserGroup>(0);
        [DataMember(Name="user_groups"), Preserve]
        public List<UserGroupListUserGroup> _userGroups { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "UserGroups: [", string.Join(", ", UserGroups), "], ");
            return output;
        }
    }

    /// <summary>
    /// Validated Purchase stored by Nakama.
    /// </summary>
    public interface IApiValidatedPurchase
    {

        /// <summary>
        /// Timestamp when the receipt validation was stored in DB.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// Whether the purchase was done in production or sandbox environment.
        /// </summary>
        ApiStoreEnvironment Environment { get; }

        /// <summary>
        /// Purchase Product ID.
        /// </summary>
        string ProductId { get; }

        /// <summary>
        /// Raw provider validation response.
        /// </summary>
        string ProviderResponse { get; }

        /// <summary>
        /// Timestamp when the purchase was done.
        /// </summary>
        string PurchaseTime { get; }

        /// <summary>
        /// Timestamp when the purchase was refunded. Set to UNIX
        /// </summary>
        string RefundTime { get; }

        /// <summary>
        /// Whether the purchase had already been validated by Nakama before.
        /// </summary>
        bool SeenBefore { get; }

        /// <summary>
        /// Store identifier
        /// </summary>
        ApiStoreProvider Store { get; }

        /// <summary>
        /// Purchase Transaction ID.
        /// </summary>
        string TransactionId { get; }

        /// <summary>
        /// Timestamp when the receipt validation was updated in DB.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// Purchase User ID.
        /// </summary>
        string UserId { get; }
    }

    /// <inheritdoc />
    internal class ApiValidatedPurchase : IApiValidatedPurchase
    {

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public ApiStoreEnvironment Environment => _environment;
        [DataMember(Name="environment"), Preserve]
        public ApiStoreEnvironment _environment { get; set; }

        /// <inheritdoc />
        [DataMember(Name="product_id"), Preserve]
        public string ProductId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="provider_response"), Preserve]
        public string ProviderResponse { get; set; }

        /// <inheritdoc />
        [DataMember(Name="purchase_time"), Preserve]
        public string PurchaseTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="refund_time"), Preserve]
        public string RefundTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="seen_before"), Preserve]
        public bool SeenBefore { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public ApiStoreProvider Store => _store;
        [DataMember(Name="store"), Preserve]
        public ApiStoreProvider _store { get; set; }

        /// <inheritdoc />
        [DataMember(Name="transaction_id"), Preserve]
        public string TransactionId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Environment: ", Environment, ", ");
            output = string.Concat(output, "ProductId: ", ProductId, ", ");
            output = string.Concat(output, "ProviderResponse: ", ProviderResponse, ", ");
            output = string.Concat(output, "PurchaseTime: ", PurchaseTime, ", ");
            output = string.Concat(output, "RefundTime: ", RefundTime, ", ");
            output = string.Concat(output, "SeenBefore: ", SeenBefore, ", ");
            output = string.Concat(output, "Store: ", Store, ", ");
            output = string.Concat(output, "TransactionId: ", TransactionId, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            return output;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public interface IApiValidatedSubscription
    {

        /// <summary>
        /// Whether the subscription is currently active or not.
        /// </summary>
        bool Active { get; }

        /// <summary>
        /// UNIX Timestamp when the receipt validation was stored in DB.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// Whether the purchase was done in production or sandbox environment.
        /// </summary>
        ApiStoreEnvironment Environment { get; }

        /// <summary>
        /// Subscription expiration time. The subscription can still be auto-renewed to extend the expiration time further.
        /// </summary>
        string ExpiryTime { get; }

        /// <summary>
        /// Purchase Original transaction ID (we only keep track of the original subscription, not subsequent renewals).
        /// </summary>
        string OriginalTransactionId { get; }

        /// <summary>
        /// Purchase Product ID.
        /// </summary>
        string ProductId { get; }

        /// <summary>
        /// Raw provider notification body.
        /// </summary>
        string ProviderNotification { get; }

        /// <summary>
        /// Raw provider validation response body.
        /// </summary>
        string ProviderResponse { get; }

        /// <summary>
        /// UNIX Timestamp when the purchase was done.
        /// </summary>
        string PurchaseTime { get; }

        /// <summary>
        /// Subscription refund time. If this time is set, the subscription was refunded.
        /// </summary>
        string RefundTime { get; }

        /// <summary>
        /// Store identifier
        /// </summary>
        ApiStoreProvider Store { get; }

        /// <summary>
        /// UNIX Timestamp when the receipt validation was updated in DB.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// Subscription User ID.
        /// </summary>
        string UserId { get; }
    }

    /// <inheritdoc />
    internal class ApiValidatedSubscription : IApiValidatedSubscription
    {

        /// <inheritdoc />
        [DataMember(Name="active"), Preserve]
        public bool Active { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public ApiStoreEnvironment Environment => _environment;
        [DataMember(Name="environment"), Preserve]
        public ApiStoreEnvironment _environment { get; set; }

        /// <inheritdoc />
        [DataMember(Name="expiry_time"), Preserve]
        public string ExpiryTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="original_transaction_id"), Preserve]
        public string OriginalTransactionId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="product_id"), Preserve]
        public string ProductId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="provider_notification"), Preserve]
        public string ProviderNotification { get; set; }

        /// <inheritdoc />
        [DataMember(Name="provider_response"), Preserve]
        public string ProviderResponse { get; set; }

        /// <inheritdoc />
        [DataMember(Name="purchase_time"), Preserve]
        public string PurchaseTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="refund_time"), Preserve]
        public string RefundTime { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public ApiStoreProvider Store => _store;
        [DataMember(Name="store"), Preserve]
        public ApiStoreProvider _store { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Active: ", Active, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Environment: ", Environment, ", ");
            output = string.Concat(output, "ExpiryTime: ", ExpiryTime, ", ");
            output = string.Concat(output, "OriginalTransactionId: ", OriginalTransactionId, ", ");
            output = string.Concat(output, "ProductId: ", ProductId, ", ");
            output = string.Concat(output, "ProviderNotification: ", ProviderNotification, ", ");
            output = string.Concat(output, "ProviderResponse: ", ProviderResponse, ", ");
            output = string.Concat(output, "PurchaseTime: ", PurchaseTime, ", ");
            output = string.Concat(output, "RefundTime: ", RefundTime, ", ");
            output = string.Concat(output, "Store: ", Store, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            return output;
        }
    }

    /// <summary>
    /// An export of all information stored for a user account.
    /// </summary>
    public interface IConsoleAccountExport
    {

        /// <summary>
        /// The user's account details.
        /// </summary>
        INakamaapiAccount Account { get; }

        /// <summary>
        /// The user's friends.
        /// </summary>
        IEnumerable<IApiFriend> Friends { get; }

        /// <summary>
        /// The user's groups.
        /// </summary>
        IEnumerable<IApiGroup> Groups { get; }

        /// <summary>
        /// The user's leaderboard records.
        /// </summary>
        IEnumerable<IApiLeaderboardRecord> LeaderboardRecords { get; }

        /// <summary>
        /// The user's chat messages.
        /// </summary>
        IEnumerable<IApiChannelMessage> Messages { get; }

        /// <summary>
        /// The user's notifications.
        /// </summary>
        IEnumerable<INakamaapiNotification> Notifications { get; }

        /// <summary>
        /// The user's storage.
        /// </summary>
        IEnumerable<IApiStorageObject> Objects { get; }

        /// <summary>
        /// The user's wallet ledger items.
        /// </summary>
        IEnumerable<IConsoleWalletLedger> WalletLedgers { get; }
    }

    /// <inheritdoc />
    internal class ConsoleAccountExport : IConsoleAccountExport
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public INakamaapiAccount Account => _account;
        [DataMember(Name="account"), Preserve]
        public NakamaapiAccount _account { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiFriend> Friends => _friends ?? new List<ApiFriend>(0);
        [DataMember(Name="friends"), Preserve]
        public List<ApiFriend> _friends { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiGroup> Groups => _groups ?? new List<ApiGroup>(0);
        [DataMember(Name="groups"), Preserve]
        public List<ApiGroup> _groups { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiLeaderboardRecord> LeaderboardRecords => _leaderboardRecords ?? new List<ApiLeaderboardRecord>(0);
        [DataMember(Name="leaderboard_records"), Preserve]
        public List<ApiLeaderboardRecord> _leaderboardRecords { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiChannelMessage> Messages => _messages ?? new List<ApiChannelMessage>(0);
        [DataMember(Name="messages"), Preserve]
        public List<ApiChannelMessage> _messages { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<INakamaapiNotification> Notifications => _notifications ?? new List<NakamaapiNotification>(0);
        [DataMember(Name="notifications"), Preserve]
        public List<NakamaapiNotification> _notifications { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiStorageObject> Objects => _objects ?? new List<ApiStorageObject>(0);
        [DataMember(Name="objects"), Preserve]
        public List<ApiStorageObject> _objects { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConsoleWalletLedger> WalletLedgers => _walletLedgers ?? new List<ConsoleWalletLedger>(0);
        [DataMember(Name="wallet_ledgers"), Preserve]
        public List<ConsoleWalletLedger> _walletLedgers { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Account: ", Account, ", ");
            output = string.Concat(output, "Friends: [", string.Join(", ", Friends), "], ");
            output = string.Concat(output, "Groups: [", string.Join(", ", Groups), "], ");
            output = string.Concat(output, "LeaderboardRecords: [", string.Join(", ", LeaderboardRecords), "], ");
            output = string.Concat(output, "Messages: [", string.Join(", ", Messages), "], ");
            output = string.Concat(output, "Notifications: [", string.Join(", ", Notifications), "], ");
            output = string.Concat(output, "Objects: [", string.Join(", ", Objects), "], ");
            output = string.Concat(output, "WalletLedgers: [", string.Join(", ", WalletLedgers), "], ");
            return output;
        }
    }

    /// <summary>
    /// A list of users.
    /// </summary>
    public interface IConsoleAccountList
    {

        /// <summary>
        /// Next cursor.
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// Approximate total number of users.
        /// </summary>
        int TotalCount { get; }

        /// <summary>
        /// A list of users.
        /// </summary>
        IEnumerable<INakamaapiUser> Users { get; }
    }

    /// <inheritdoc />
    internal class ConsoleAccountList : IConsoleAccountList
    {

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        [DataMember(Name="total_count"), Preserve]
        public int TotalCount { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<INakamaapiUser> Users => _users ?? new List<NakamaapiUser>(0);
        [DataMember(Name="users"), Preserve]
        public List<NakamaapiUser> _users { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "TotalCount: ", TotalCount, ", ");
            output = string.Concat(output, "Users: [", string.Join(", ", Users), "], ");
            return output;
        }
    }

    /// <summary>
    /// Add a new console user
    /// </summary>
    public interface IConsoleAddUserRequest
    {

        /// <summary>
        /// Email address of the user.
        /// </summary>
        string Email { get; }

        /// <summary>
        /// Require MFA
        /// </summary>
        bool MfaRequired { get; }

        /// <summary>
        /// Subscribe to newsletters
        /// </summary>
        bool NewsletterSubscription { get; }

        /// <summary>
        /// The password of the user.
        /// </summary>
        string Password { get; }

        /// <summary>
        /// Role of this user;
        /// </summary>
        ConsoleUserRole Role { get; }

        /// <summary>
        /// The username of the user.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class ConsoleAddUserRequest : IConsoleAddUserRequest
    {

        /// <inheritdoc />
        [DataMember(Name="email"), Preserve]
        public string Email { get; set; }

        /// <inheritdoc />
        [DataMember(Name="mfa_required"), Preserve]
        public bool MfaRequired { get; set; }

        /// <inheritdoc />
        [DataMember(Name="newsletter_subscription"), Preserve]
        public bool NewsletterSubscription { get; set; }

        /// <inheritdoc />
        [DataMember(Name="password"), Preserve]
        public string Password { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public ConsoleUserRole Role => _role;
        [DataMember(Name="role"), Preserve]
        public ConsoleUserRole _role { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Email: ", Email, ", ");
            output = string.Concat(output, "MfaRequired: ", MfaRequired, ", ");
            output = string.Concat(output, "NewsletterSubscription: ", NewsletterSubscription, ", ");
            output = string.Concat(output, "Password: ", Password, ", ");
            output = string.Concat(output, "Role: ", Role, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// API Explorer List of Endpoints response message
    /// </summary>
    public interface IConsoleApiEndpointDescriptor
    {

        /// <summary>
        /// 
        /// </summary>
        string BodyTemplate { get; }

        /// <summary>
        /// 
        /// </summary>
        string Method { get; }
    }

    /// <inheritdoc />
    internal class ConsoleApiEndpointDescriptor : IConsoleApiEndpointDescriptor
    {

        /// <inheritdoc />
        [DataMember(Name="body_template"), Preserve]
        public string BodyTemplate { get; set; }

        /// <inheritdoc />
        [DataMember(Name="method"), Preserve]
        public string Method { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "BodyTemplate: ", BodyTemplate, ", ");
            output = string.Concat(output, "Method: ", Method, ", ");
            return output;
        }
    }

    /// <summary>
    /// API Explorer List of Endpoints
    /// </summary>
    public interface IConsoleApiEndpointList
    {

        /// <summary>
        /// 
        /// </summary>
        IEnumerable<IConsoleApiEndpointDescriptor> Endpoints { get; }

        /// <summary>
        /// 
        /// </summary>
        IEnumerable<IConsoleApiEndpointDescriptor> RpcEndpoints { get; }
    }

    /// <inheritdoc />
    internal class ConsoleApiEndpointList : IConsoleApiEndpointList
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConsoleApiEndpointDescriptor> Endpoints => _endpoints ?? new List<ConsoleApiEndpointDescriptor>(0);
        [DataMember(Name="endpoints"), Preserve]
        public List<ConsoleApiEndpointDescriptor> _endpoints { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConsoleApiEndpointDescriptor> RpcEndpoints => _rpcEndpoints ?? new List<ConsoleApiEndpointDescriptor>(0);
        [DataMember(Name="rpc_endpoints"), Preserve]
        public List<ConsoleApiEndpointDescriptor> _rpcEndpoints { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Endpoints: [", string.Join(", ", Endpoints), "], ");
            output = string.Concat(output, "RpcEndpoints: [", string.Join(", ", RpcEndpoints), "], ");
            return output;
        }
    }

    /// <summary>
    /// Log out a session and invalidate a session token.
    /// </summary>
    public interface IConsoleAuthenticateLogoutRequest
    {

        /// <summary>
        /// Session token to log out.
        /// </summary>
        string Token { get; }
    }

    /// <inheritdoc />
    internal class ConsoleAuthenticateLogoutRequest : IConsoleAuthenticateLogoutRequest
    {

        /// <inheritdoc />
        [DataMember(Name="token"), Preserve]
        public string Token { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Token: ", Token, ", ");
            return output;
        }
    }

    /// <summary>
    /// Request to change MFA.
    /// </summary>
    public interface IConsoleAuthenticateMFASetupRequest
    {

        /// <summary>
        /// MFA code.
        /// </summary>
        string Code { get; }

        /// <summary>
        /// MFA token.
        /// </summary>
        string Mfa { get; }
    }

    /// <inheritdoc />
    internal class ConsoleAuthenticateMFASetupRequest : IConsoleAuthenticateMFASetupRequest
    {

        /// <inheritdoc />
        [DataMember(Name="code"), Preserve]
        public string Code { get; set; }

        /// <inheritdoc />
        [DataMember(Name="mfa"), Preserve]
        public string Mfa { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Code: ", Code, ", ");
            output = string.Concat(output, "Mfa: ", Mfa, ", ");
            return output;
        }
    }

    /// <summary>
    /// Response to change MFA.
    /// </summary>
    public interface IConsoleAuthenticateMFASetupResponse
    {

        /// <summary>
        /// An one-time code to configure the MFA mechanism
        /// </summary>
        List<string> RecoveryCodes { get; }
    }

    /// <inheritdoc />
    internal class ConsoleAuthenticateMFASetupResponse : IConsoleAuthenticateMFASetupResponse
    {

        /// <inheritdoc />
        [DataMember(Name="recovery_codes"), Preserve]
        public List<string> RecoveryCodes { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "RecoveryCodes: [", string.Join(", ", RecoveryCodes), "], ");
            return output;
        }
    }

    /// <summary>
    /// Authenticate a console user with username and password.
    /// </summary>
    public interface IConsoleAuthenticateRequest
    {

        /// <summary>
        /// Multi-factor authentication code.
        /// </summary>
        string Mfa { get; }

        /// <summary>
        /// The password of the user.
        /// </summary>
        string Password { get; }

        /// <summary>
        /// The username of the user.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class ConsoleAuthenticateRequest : IConsoleAuthenticateRequest
    {

        /// <inheritdoc />
        [DataMember(Name="mfa"), Preserve]
        public string Mfa { get; set; }

        /// <inheritdoc />
        [DataMember(Name="password"), Preserve]
        public string Password { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Mfa: ", Mfa, ", ");
            output = string.Concat(output, "Password: ", Password, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// API Explorer response definition for CallApiEndpoint
    /// </summary>
    public interface IConsoleCallApiEndpointResponse
    {

        /// <summary>
        /// 
        /// </summary>
        string Body { get; }

        /// <summary>
        /// 
        /// </summary>
        string ErrorMessage { get; }
    }

    /// <inheritdoc />
    internal class ConsoleCallApiEndpointResponse : IConsoleCallApiEndpointResponse
    {

        /// <inheritdoc />
        [DataMember(Name="body"), Preserve]
        public string Body { get; set; }

        /// <inheritdoc />
        [DataMember(Name="error_message"), Preserve]
        public string ErrorMessage { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Body: ", Body, ", ");
            output = string.Concat(output, "ErrorMessage: ", ErrorMessage, ", ");
            return output;
        }
    }

    /// <summary>
    /// The current server configuration and any associated warnings.
    /// </summary>
    public interface IConsoleConfig
    {

        /// <summary>
        /// JSON-encoded active server configuration.
        /// </summary>
        string Config { get; }

        /// <summary>
        /// Server version
        /// </summary>
        string ServerVersion { get; }

        /// <summary>
        /// Any warnings about the current config.
        /// </summary>
        IEnumerable<IConfigWarning> Warnings { get; }
    }

    /// <inheritdoc />
    internal class ConsoleConfig : IConsoleConfig
    {

        /// <inheritdoc />
        [DataMember(Name="config"), Preserve]
        public string Config { get; set; }

        /// <inheritdoc />
        [DataMember(Name="server_version"), Preserve]
        public string ServerVersion { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConfigWarning> Warnings => _warnings ?? new List<ConfigWarning>(0);
        [DataMember(Name="warnings"), Preserve]
        public List<ConfigWarning> _warnings { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Config: ", Config, ", ");
            output = string.Concat(output, "ServerVersion: ", ServerVersion, ", ");
            output = string.Concat(output, "Warnings: [", string.Join(", ", Warnings), "], ");
            return output;
        }
    }

    /// <summary>
    /// A console user session.
    /// </summary>
    public interface IConsoleConsoleSession
    {

        /// <summary>
        /// MFA code required to setup the MFA mechanism.
        /// </summary>
        string MfaCode { get; }

        /// <summary>
        /// A session token (JWT) for the console user.
        /// </summary>
        string Token { get; }
    }

    /// <inheritdoc />
    internal class ConsoleConsoleSession : IConsoleConsoleSession
    {

        /// <inheritdoc />
        [DataMember(Name="mfa_code"), Preserve]
        public string MfaCode { get; set; }

        /// <inheritdoc />
        [DataMember(Name="token"), Preserve]
        public string Token { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "MfaCode: ", MfaCode, ", ");
            output = string.Concat(output, "Token: ", Token, ", ");
            return output;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public interface IConsoleDeleteChannelMessagesResponse
    {

        /// <summary>
        /// Total number of messages deleted.
        /// </summary>
        string Total { get; }
    }

    /// <inheritdoc />
    internal class ConsoleDeleteChannelMessagesResponse : IConsoleDeleteChannelMessagesResponse
    {

        /// <inheritdoc />
        [DataMember(Name="total"), Preserve]
        public string Total { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Total: ", Total, ", ");
            return output;
        }
    }

    /// <summary>
    /// An export of all information stored for a group.
    /// </summary>
    public interface IConsoleGroupExport
    {

        /// <summary>
        /// The group details.
        /// </summary>
        IApiGroup Group { get; }

        /// <summary>
        /// The group's list of members.
        /// </summary>
        IEnumerable<IGroupUserListGroupUser> Members { get; }
    }

    /// <inheritdoc />
    internal class ConsoleGroupExport : IConsoleGroupExport
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IApiGroup Group => _group;
        [DataMember(Name="group"), Preserve]
        public ApiGroup _group { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IGroupUserListGroupUser> Members => _members ?? new List<GroupUserListGroupUser>(0);
        [DataMember(Name="members"), Preserve]
        public List<GroupUserListGroupUser> _members { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Group: ", Group, ", ");
            output = string.Concat(output, "Members: [", string.Join(", ", Members), "], ");
            return output;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public enum ConsoleListChannelMessagesRequestType
    {
        /// <summary>
        /// 
        /// </summary>
        UNKNOWN = 0,
        /// <summary>
        /// 
        /// </summary>
        ROOM = 1,
        /// <summary>
        /// 
        /// </summary>
        GROUP = 2,
        /// <summary>
        /// 
        /// </summary>
        DIRECT = 3,
    }

    /// <summary>
    /// 
    /// </summary>
    public interface IConsoleMatchListMatch
    {

        /// <summary>
        /// The API match
        /// </summary>
        INakamaapiMatch ApiMatch { get; }

        /// <summary>
        /// The node name
        /// </summary>
        string Node { get; }
    }

    /// <inheritdoc />
    internal class ConsoleMatchListMatch : IConsoleMatchListMatch
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public INakamaapiMatch ApiMatch => _apiMatch;
        [DataMember(Name="api_match"), Preserve]
        public NakamaapiMatch _apiMatch { get; set; }

        /// <inheritdoc />
        [DataMember(Name="node"), Preserve]
        public string Node { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "ApiMatch: ", ApiMatch, ", ");
            output = string.Concat(output, "Node: ", Node, ", ");
            return output;
        }
    }

    /// <summary>
    /// Match state
    /// </summary>
    public interface IConsoleMatchState
    {

        /// <summary>
        /// Presence list.
        /// </summary>
        IEnumerable<IRealtimeUserPresence> Presences { get; }

        /// <summary>
        /// State.
        /// </summary>
        string State { get; }

        /// <summary>
        /// Current tick number.
        /// </summary>
        string Tick { get; }
    }

    /// <inheritdoc />
    internal class ConsoleMatchState : IConsoleMatchState
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IRealtimeUserPresence> Presences => _presences ?? new List<RealtimeUserPresence>(0);
        [DataMember(Name="presences"), Preserve]
        public List<RealtimeUserPresence> _presences { get; set; }

        /// <inheritdoc />
        [DataMember(Name="state"), Preserve]
        public string State { get; set; }

        /// <inheritdoc />
        [DataMember(Name="tick"), Preserve]
        public string Tick { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Presences: [", string.Join(", ", Presences), "], ");
            output = string.Concat(output, "State: ", State, ", ");
            output = string.Concat(output, "Tick: ", Tick, ", ");
            return output;
        }
    }

    /// <summary>
    /// Runtime information
    /// </summary>
    public interface IConsoleRuntimeInfo
    {

        /// <summary>
        /// Go loaded modules
        /// </summary>
        IEnumerable<IRuntimeInfoModuleInfo> GoModules { get; }

        /// <summary>
        /// Go registered RPC functions
        /// </summary>
        List<string> GoRpcFunctions { get; }

        /// <summary>
        /// JavaScript loaded modules
        /// </summary>
        IEnumerable<IRuntimeInfoModuleInfo> JsModules { get; }

        /// <summary>
        /// JavaScript registered RPC functions
        /// </summary>
        List<string> JsRpcFunctions { get; }

        /// <summary>
        /// Lua loaded modules
        /// </summary>
        IEnumerable<IRuntimeInfoModuleInfo> LuaModules { get; }

        /// <summary>
        /// Lua registered RPC functions
        /// </summary>
        List<string> LuaRpcFunctions { get; }
    }

    /// <inheritdoc />
    internal class ConsoleRuntimeInfo : IConsoleRuntimeInfo
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IRuntimeInfoModuleInfo> GoModules => _goModules ?? new List<RuntimeInfoModuleInfo>(0);
        [DataMember(Name="go_modules"), Preserve]
        public List<RuntimeInfoModuleInfo> _goModules { get; set; }

        /// <inheritdoc />
        [DataMember(Name="go_rpc_functions"), Preserve]
        public List<string> GoRpcFunctions { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IRuntimeInfoModuleInfo> JsModules => _jsModules ?? new List<RuntimeInfoModuleInfo>(0);
        [DataMember(Name="js_modules"), Preserve]
        public List<RuntimeInfoModuleInfo> _jsModules { get; set; }

        /// <inheritdoc />
        [DataMember(Name="js_rpc_functions"), Preserve]
        public List<string> JsRpcFunctions { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IRuntimeInfoModuleInfo> LuaModules => _luaModules ?? new List<RuntimeInfoModuleInfo>(0);
        [DataMember(Name="lua_modules"), Preserve]
        public List<RuntimeInfoModuleInfo> _luaModules { get; set; }

        /// <inheritdoc />
        [DataMember(Name="lua_rpc_functions"), Preserve]
        public List<string> LuaRpcFunctions { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "GoModules: [", string.Join(", ", GoModules), "], ");
            output = string.Concat(output, "GoRpcFunctions: [", string.Join(", ", GoRpcFunctions), "], ");
            output = string.Concat(output, "JsModules: [", string.Join(", ", JsModules), "], ");
            output = string.Concat(output, "JsRpcFunctions: [", string.Join(", ", JsRpcFunctions), "], ");
            output = string.Concat(output, "LuaModules: [", string.Join(", ", LuaModules), "], ");
            output = string.Concat(output, "LuaRpcFunctions: [", string.Join(", ", LuaRpcFunctions), "], ");
            return output;
        }
    }

    /// <summary>
    /// A single setting.
    /// </summary>
    public interface IConsoleSetting
    {

        /// <summary>
        /// Name identifier.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Update time.
        /// </summary>
        string UpdateTimeSec { get; }

        /// <summary>
        /// Setting value.
        /// </summary>
        string Value { get; }
    }

    /// <inheritdoc />
    internal class ConsoleSetting : IConsoleSetting
    {

        /// <inheritdoc />
        [DataMember(Name="name"), Preserve]
        public string Name { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time_sec"), Preserve]
        public string UpdateTimeSec { get; set; }

        /// <inheritdoc />
        [DataMember(Name="value"), Preserve]
        public string Value { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Name: ", Name, ", ");
            output = string.Concat(output, "UpdateTimeSec: ", UpdateTimeSec, ", ");
            output = string.Concat(output, "Value: ", Value, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of settings.
    /// </summary>
    public interface IConsoleSettingList
    {

        /// <summary>
        /// A list of settings.
        /// </summary>
        IEnumerable<IConsoleSetting> Settings { get; }
    }

    /// <inheritdoc />
    internal class ConsoleSettingList : IConsoleSettingList
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConsoleSetting> Settings => _settings ?? new List<ConsoleSetting>(0);
        [DataMember(Name="settings"), Preserve]
        public List<ConsoleSetting> _settings { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Settings: [", string.Join(", ", Settings), "], ");
            return output;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public enum ConsoleStatusHealth
    {
        /// <summary>
        /// 
        /// </summary>
        STATUS_HEALTH_OK = 0,
        /// <summary>
        /// 
        /// </summary>
        STATUS_HEALTH_ERROR = 1,
        /// <summary>
        /// 
        /// </summary>
        STATUS_HEALTH_CONNECTING = 2,
        /// <summary>
        /// 
        /// </summary>
        STATUS_HEALTH_DISCONNECTING = 3,
    }

    /// <summary>
    /// List of nodes and their stats.
    /// </summary>
    public interface IConsoleStatusList
    {

        /// <summary>
        /// List of nodes and their stats.
        /// </summary>
        IEnumerable<IConsoleStatusListStatus> Nodes { get; }

        /// <summary>
        /// Timestamp
        /// </summary>
        string Timestamp { get; }
    }

    /// <inheritdoc />
    internal class ConsoleStatusList : IConsoleStatusList
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConsoleStatusListStatus> Nodes => _nodes ?? new List<ConsoleStatusListStatus>(0);
        [DataMember(Name="nodes"), Preserve]
        public List<ConsoleStatusListStatus> _nodes { get; set; }

        /// <inheritdoc />
        [DataMember(Name="timestamp"), Preserve]
        public string Timestamp { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Nodes: [", string.Join(", ", Nodes), "], ");
            output = string.Concat(output, "Timestamp: ", Timestamp, ", ");
            return output;
        }
    }

    /// <summary>
    /// The status of a Nakama node.
    /// </summary>
    public interface IConsoleStatusListStatus
    {

        /// <summary>
        /// Average input bandwidth usage.
        /// </summary>
        double AvgInputKbs { get; }

        /// <summary>
        /// Average response latency in milliseconds.
        /// </summary>
        double AvgLatencyMs { get; }

        /// <summary>
        /// Average output bandwidth usage.
        /// </summary>
        double AvgOutputKbs { get; }

        /// <summary>
        /// Average number of requests per second.
        /// </summary>
        double AvgRateSec { get; }

        /// <summary>
        /// Current number of running goroutines.
        /// </summary>
        int GoroutineCount { get; }

        /// <summary>
        /// Health score.
        /// </summary>
        ConsoleStatusHealth Health { get; }

        /// <summary>
        /// Current number of active authoritative matches.
        /// </summary>
        int MatchCount { get; }

        /// <summary>
        /// Node name.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Currently registered live presences.
        /// </summary>
        int PresenceCount { get; }

        /// <summary>
        /// Currently connected sessions.
        /// </summary>
        int SessionCount { get; }
    }

    /// <inheritdoc />
    internal class ConsoleStatusListStatus : IConsoleStatusListStatus
    {

        /// <inheritdoc />
        [DataMember(Name="avg_input_kbs"), Preserve]
        public double AvgInputKbs { get; set; }

        /// <inheritdoc />
        [DataMember(Name="avg_latency_ms"), Preserve]
        public double AvgLatencyMs { get; set; }

        /// <inheritdoc />
        [DataMember(Name="avg_output_kbs"), Preserve]
        public double AvgOutputKbs { get; set; }

        /// <inheritdoc />
        [DataMember(Name="avg_rate_sec"), Preserve]
        public double AvgRateSec { get; set; }

        /// <inheritdoc />
        [DataMember(Name="goroutine_count"), Preserve]
        public int GoroutineCount { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public ConsoleStatusHealth Health => _health;
        [DataMember(Name="health"), Preserve]
        public ConsoleStatusHealth _health { get; set; }

        /// <inheritdoc />
        [DataMember(Name="match_count"), Preserve]
        public int MatchCount { get; set; }

        /// <inheritdoc />
        [DataMember(Name="name"), Preserve]
        public string Name { get; set; }

        /// <inheritdoc />
        [DataMember(Name="presence_count"), Preserve]
        public int PresenceCount { get; set; }

        /// <inheritdoc />
        [DataMember(Name="session_count"), Preserve]
        public int SessionCount { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "AvgInputKbs: ", AvgInputKbs, ", ");
            output = string.Concat(output, "AvgLatencyMs: ", AvgLatencyMs, ", ");
            output = string.Concat(output, "AvgOutputKbs: ", AvgOutputKbs, ", ");
            output = string.Concat(output, "AvgRateSec: ", AvgRateSec, ", ");
            output = string.Concat(output, "GoroutineCount: ", GoroutineCount, ", ");
            output = string.Concat(output, "Health: ", Health, ", ");
            output = string.Concat(output, "MatchCount: ", MatchCount, ", ");
            output = string.Concat(output, "Name: ", Name, ", ");
            output = string.Concat(output, "PresenceCount: ", PresenceCount, ", ");
            output = string.Concat(output, "SessionCount: ", SessionCount, ", ");
            return output;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public interface IConsoleStorageCollectionsList
    {

        /// <summary>
        /// Available collection names in the whole of the storage
        /// </summary>
        List<string> Collections { get; }
    }

    /// <inheritdoc />
    internal class ConsoleStorageCollectionsList : IConsoleStorageCollectionsList
    {

        /// <inheritdoc />
        [DataMember(Name="collections"), Preserve]
        public List<string> Collections { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Collections: [", string.Join(", ", Collections), "], ");
            return output;
        }
    }

    /// <summary>
    /// List of storage objects.
    /// </summary>
    public interface IConsoleStorageList
    {

        /// <summary>
        /// Next page cursor if any
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// List of storage objects matching list/filter operation.
        /// </summary>
        IEnumerable<IConsoleStorageListObject> Objects { get; }

        /// <summary>
        /// Approximate total number of storage objects.
        /// </summary>
        int TotalCount { get; }
    }

    /// <inheritdoc />
    internal class ConsoleStorageList : IConsoleStorageList
    {

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConsoleStorageListObject> Objects => _objects ?? new List<ConsoleStorageListObject>(0);
        [DataMember(Name="objects"), Preserve]
        public List<ConsoleStorageListObject> _objects { get; set; }

        /// <inheritdoc />
        [DataMember(Name="total_count"), Preserve]
        public int TotalCount { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "Objects: [", string.Join(", ", Objects), "], ");
            output = string.Concat(output, "TotalCount: ", TotalCount, ", ");
            return output;
        }
    }

    /// <summary>
    /// An object within the storage engine.
    /// </summary>
    public interface IConsoleStorageListObject
    {

        /// <summary>
        /// The collection which stores the object.
        /// </summary>
        string Collection { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The key of the object within the collection.
        /// </summary>
        string Key { get; }

        /// <summary>
        /// The read access permissions for the object.
        /// </summary>
        int PermissionRead { get; }

        /// <summary>
        /// The write access permissions for the object.
        /// </summary>
        int PermissionWrite { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was last updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The user owner of the object.
        /// </summary>
        string UserId { get; }

        /// <summary>
        /// The version hash of the object.
        /// </summary>
        string Version { get; }
    }

    /// <inheritdoc />
    internal class ConsoleStorageListObject : IConsoleStorageListObject
    {

        /// <inheritdoc />
        [DataMember(Name="collection"), Preserve]
        public string Collection { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="key"), Preserve]
        public string Key { get; set; }

        /// <inheritdoc />
        [DataMember(Name="permission_read"), Preserve]
        public int PermissionRead { get; set; }

        /// <inheritdoc />
        [DataMember(Name="permission_write"), Preserve]
        public int PermissionWrite { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="version"), Preserve]
        public string Version { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Collection: ", Collection, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Key: ", Key, ", ");
            output = string.Concat(output, "PermissionRead: ", PermissionRead, ", ");
            output = string.Concat(output, "PermissionWrite: ", PermissionWrite, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            output = string.Concat(output, "Version: ", Version, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of console users.
    /// </summary>
    public interface IConsoleUserList
    {

        /// <summary>
        /// A list of users.
        /// </summary>
        IEnumerable<IConsoleUserListUser> Users { get; }
    }

    /// <inheritdoc />
    internal class ConsoleUserList : IConsoleUserList
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConsoleUserListUser> Users => _users ?? new List<ConsoleUserListUser>(0);
        [DataMember(Name="users"), Preserve]
        public List<ConsoleUserListUser> _users { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Users: [", string.Join(", ", Users), "], ");
            return output;
        }
    }

    /// <summary>
    /// A console user
    /// </summary>
    public interface IConsoleUserListUser
    {

        /// <summary>
        /// Email of the user
        /// </summary>
        string Email { get; }

        /// <summary>
        /// Whether the user has MFA enabled.
        /// </summary>
        bool MfaEnabled { get; }

        /// <summary>
        /// Whether the user is required to setup MFA.
        /// </summary>
        bool MfaRequired { get; }

        /// <summary>
        /// Role of the user;
        /// </summary>
        ConsoleUserRole Role { get; }

        /// <summary>
        /// Username of the user
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class ConsoleUserListUser : IConsoleUserListUser
    {

        /// <inheritdoc />
        [DataMember(Name="email"), Preserve]
        public string Email { get; set; }

        /// <inheritdoc />
        [DataMember(Name="mfa_enabled"), Preserve]
        public bool MfaEnabled { get; set; }

        /// <inheritdoc />
        [DataMember(Name="mfa_required"), Preserve]
        public bool MfaRequired { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public ConsoleUserRole Role => _role;
        [DataMember(Name="role"), Preserve]
        public ConsoleUserRole _role { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Email: ", Email, ", ");
            output = string.Concat(output, "MfaEnabled: ", MfaEnabled, ", ");
            output = string.Concat(output, "MfaRequired: ", MfaRequired, ", ");
            output = string.Concat(output, "Role: ", Role, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// - USER_ROLE_ADMIN: All access
 - USER_ROLE_DEVELOPER: Best for developers, also enables APIs and API explorer
 - USER_ROLE_MAINTAINER: Best for users who regularly update player information.
 - USER_ROLE_READONLY: Read-only role for those only need to view data
    /// </summary>
    public enum ConsoleUserRole
    {
        /// <summary>
        /// 
        /// </summary>
        USER_ROLE_UNKNOWN = 0,
        /// <summary>
        /// 
        /// </summary>
        USER_ROLE_ADMIN = 1,
        /// <summary>
        /// 
        /// </summary>
        USER_ROLE_DEVELOPER = 2,
        /// <summary>
        /// 
        /// </summary>
        USER_ROLE_MAINTAINER = 3,
        /// <summary>
        /// 
        /// </summary>
        USER_ROLE_READONLY = 4,
    }

    /// <summary>
    /// An individual update to a user's wallet.
    /// </summary>
    public interface IConsoleWalletLedger
    {

        /// <summary>
        /// The changeset.
        /// </summary>
        string Changeset { get; }

        /// <summary>
        /// The UNIX time when the wallet ledger item was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The identifier of this wallet change.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// Any associated metadata.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The UNIX time when the wallet ledger item was updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The user ID this wallet ledger item belongs to.
        /// </summary>
        string UserId { get; }
    }

    /// <inheritdoc />
    internal class ConsoleWalletLedger : IConsoleWalletLedger
    {

        /// <inheritdoc />
        [DataMember(Name="changeset"), Preserve]
        public string Changeset { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Changeset: ", Changeset, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            return output;
        }
    }

    /// <summary>
    /// List of wallet ledger items for a particular user.
    /// </summary>
    public interface IConsoleWalletLedgerList
    {

        /// <summary>
        /// A list of wallet ledger items.
        /// </summary>
        IEnumerable<IConsoleWalletLedger> Items { get; }

        /// <summary>
        /// The cursor to send when retrieving the next older page, if any.
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// The cursor to send when retrieving the previous page newer, if any.
        /// </summary>
        string PrevCursor { get; }
    }

    /// <inheritdoc />
    internal class ConsoleWalletLedgerList : IConsoleWalletLedgerList
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConsoleWalletLedger> Items => _items ?? new List<ConsoleWalletLedger>(0);
        [DataMember(Name="items"), Preserve]
        public List<ConsoleWalletLedger> _items { get; set; }

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_cursor"), Preserve]
        public string PrevCursor { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Items: [", string.Join(", ", Items), "], ");
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "PrevCursor: ", PrevCursor, ", ");
            return output;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public interface IGooglerpcStatus
    {

        /// <summary>
        /// 
        /// </summary>
        int Code { get; }

        /// <summary>
        /// 
        /// </summary>
        IEnumerable<IProtobufAny> Details { get; }

        /// <summary>
        /// 
        /// </summary>
        string Message { get; }
    }

    /// <inheritdoc />
    internal class GooglerpcStatus : IGooglerpcStatus
    {

        /// <inheritdoc />
        [DataMember(Name="code"), Preserve]
        public int Code { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IProtobufAny> Details => _details ?? new List<ProtobufAny>(0);
        [DataMember(Name="details"), Preserve]
        public List<ProtobufAny> _details { get; set; }

        /// <inheritdoc />
        [DataMember(Name="message"), Preserve]
        public string Message { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Code: ", Code, ", ");
            output = string.Concat(output, "Details: [", string.Join(", ", Details), "], ");
            output = string.Concat(output, "Message: ", Message, ", ");
            return output;
        }
    }

    /// <summary>
    /// A user with additional account details. Always the current user.
    /// </summary>
    public interface INakamaapiAccount
    {

        /// <summary>
        /// The custom id in the user's account.
        /// </summary>
        string CustomId { get; }

        /// <summary>
        /// The devices which belong to the user's account.
        /// </summary>
        IEnumerable<IApiAccountDevice> Devices { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's account was disabled/banned.
        /// </summary>
        string DisableTime { get; }

        /// <summary>
        /// The email address of the user.
        /// </summary>
        string Email { get; }

        /// <summary>
        /// The user object.
        /// </summary>
        INakamaapiUser User { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's email was verified.
        /// </summary>
        string VerifyTime { get; }

        /// <summary>
        /// The user's wallet data.
        /// </summary>
        string Wallet { get; }
    }

    /// <inheritdoc />
    internal class NakamaapiAccount : INakamaapiAccount
    {

        /// <inheritdoc />
        [DataMember(Name="custom_id"), Preserve]
        public string CustomId { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiAccountDevice> Devices => _devices ?? new List<ApiAccountDevice>(0);
        [DataMember(Name="devices"), Preserve]
        public List<ApiAccountDevice> _devices { get; set; }

        /// <inheritdoc />
        [DataMember(Name="disable_time"), Preserve]
        public string DisableTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="email"), Preserve]
        public string Email { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public INakamaapiUser User => _user;
        [DataMember(Name="user"), Preserve]
        public NakamaapiUser _user { get; set; }

        /// <inheritdoc />
        [DataMember(Name="verify_time"), Preserve]
        public string VerifyTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="wallet"), Preserve]
        public string Wallet { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "CustomId: ", CustomId, ", ");
            output = string.Concat(output, "Devices: [", string.Join(", ", Devices), "], ");
            output = string.Concat(output, "DisableTime: ", DisableTime, ", ");
            output = string.Concat(output, "Email: ", Email, ", ");
            output = string.Concat(output, "User: ", User, ", ");
            output = string.Concat(output, "VerifyTime: ", VerifyTime, ", ");
            output = string.Concat(output, "Wallet: ", Wallet, ", ");
            return output;
        }
    }

    /// <summary>
    /// Represents a realtime match.
    /// </summary>
    public interface INakamaapiMatch
    {

        /// <summary>
        /// True if it's an server-managed authoritative match, false otherwise.
        /// </summary>
        bool Authoritative { get; }

        /// <summary>
        /// Handler name
        /// </summary>
        string HandlerName { get; }

        /// <summary>
        /// Match label, if any.
        /// </summary>
        string Label { get; }

        /// <summary>
        /// The ID of the match, can be used to join.
        /// </summary>
        string MatchId { get; }

        /// <summary>
        /// Current number of users in the match.
        /// </summary>
        int Size { get; }

        /// <summary>
        /// Tick Rate
        /// </summary>
        int TickRate { get; }
    }

    /// <inheritdoc />
    internal class NakamaapiMatch : INakamaapiMatch
    {

        /// <inheritdoc />
        [DataMember(Name="authoritative"), Preserve]
        public bool Authoritative { get; set; }

        /// <inheritdoc />
        [DataMember(Name="handler_name"), Preserve]
        public string HandlerName { get; set; }

        /// <inheritdoc />
        [DataMember(Name="label"), Preserve]
        public string Label { get; set; }

        /// <inheritdoc />
        [DataMember(Name="match_id"), Preserve]
        public string MatchId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="size"), Preserve]
        public int Size { get; set; }

        /// <inheritdoc />
        [DataMember(Name="tick_rate"), Preserve]
        public int TickRate { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Authoritative: ", Authoritative, ", ");
            output = string.Concat(output, "HandlerName: ", HandlerName, ", ");
            output = string.Concat(output, "Label: ", Label, ", ");
            output = string.Concat(output, "MatchId: ", MatchId, ", ");
            output = string.Concat(output, "Size: ", Size, ", ");
            output = string.Concat(output, "TickRate: ", TickRate, ", ");
            return output;
        }
    }

    /// <summary>
    /// A notification in the server.
    /// </summary>
    public interface INakamaapiNotification
    {

        /// <summary>
        /// Category code for this notification.
        /// </summary>
        int Code { get; }

        /// <summary>
        /// Content of the notification in JSON.
        /// </summary>
        string Content { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the notification was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// ID of the Notification.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// True if this notification was persisted to the database.
        /// </summary>
        bool Persistent { get; }

        /// <summary>
        /// ID of the sender, if a user. Otherwise 'null'.
        /// </summary>
        string SenderId { get; }

        /// <summary>
        /// Subject of the notification.
        /// </summary>
        string Subject { get; }
    }

    /// <inheritdoc />
    internal class NakamaapiNotification : INakamaapiNotification
    {

        /// <inheritdoc />
        [DataMember(Name="code"), Preserve]
        public int Code { get; set; }

        /// <inheritdoc />
        [DataMember(Name="content"), Preserve]
        public string Content { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="persistent"), Preserve]
        public bool Persistent { get; set; }

        /// <inheritdoc />
        [DataMember(Name="sender_id"), Preserve]
        public string SenderId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="subject"), Preserve]
        public string Subject { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Code: ", Code, ", ");
            output = string.Concat(output, "Content: ", Content, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "Persistent: ", Persistent, ", ");
            output = string.Concat(output, "SenderId: ", SenderId, ", ");
            output = string.Concat(output, "Subject: ", Subject, ", ");
            return output;
        }
    }

    /// <summary>
    /// A user in the server.
    /// </summary>
    public interface INakamaapiUser
    {

        /// <summary>
        /// The Apple Sign In ID in the user's account.
        /// </summary>
        string AppleId { get; }

        /// <summary>
        /// A URL for an avatar image.
        /// </summary>
        string AvatarUrl { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The display name of the user.
        /// </summary>
        string DisplayName { get; }

        /// <summary>
        /// Number of related edges to this user.
        /// </summary>
        int EdgeCount { get; }

        /// <summary>
        /// The Facebook id in the user's account.
        /// </summary>
        string FacebookId { get; }

        /// <summary>
        /// The Facebook Instant Game ID in the user's account.
        /// </summary>
        string FacebookInstantGameId { get; }

        /// <summary>
        /// The Apple Game Center in of the user's account.
        /// </summary>
        string GamecenterId { get; }

        /// <summary>
        /// The Google id in the user's account.
        /// </summary>
        string GoogleId { get; }

        /// <summary>
        /// The id of the user's account.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// The language expected to be a tag which follows the BCP-47 spec.
        /// </summary>
        string LangTag { get; }

        /// <summary>
        /// The location set by the user.
        /// </summary>
        string Location { get; }

        /// <summary>
        /// Additional information stored as a JSON object.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// Indicates whether the user is currently online.
        /// </summary>
        bool Online { get; }

        /// <summary>
        /// The Steam id in the user's account.
        /// </summary>
        string SteamId { get; }

        /// <summary>
        /// The timezone set by the user.
        /// </summary>
        string Timezone { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was last updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The username of the user's account.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class NakamaapiUser : INakamaapiUser
    {

        /// <inheritdoc />
        [DataMember(Name="apple_id"), Preserve]
        public string AppleId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="avatar_url"), Preserve]
        public string AvatarUrl { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="display_name"), Preserve]
        public string DisplayName { get; set; }

        /// <inheritdoc />
        [DataMember(Name="edge_count"), Preserve]
        public int EdgeCount { get; set; }

        /// <inheritdoc />
        [DataMember(Name="facebook_id"), Preserve]
        public string FacebookId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="facebook_instant_game_id"), Preserve]
        public string FacebookInstantGameId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="gamecenter_id"), Preserve]
        public string GamecenterId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="google_id"), Preserve]
        public string GoogleId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="lang_tag"), Preserve]
        public string LangTag { get; set; }

        /// <inheritdoc />
        [DataMember(Name="location"), Preserve]
        public string Location { get; set; }

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="online"), Preserve]
        public bool Online { get; set; }

        /// <inheritdoc />
        [DataMember(Name="steam_id"), Preserve]
        public string SteamId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="timezone"), Preserve]
        public string Timezone { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "AppleId: ", AppleId, ", ");
            output = string.Concat(output, "AvatarUrl: ", AvatarUrl, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "DisplayName: ", DisplayName, ", ");
            output = string.Concat(output, "EdgeCount: ", EdgeCount, ", ");
            output = string.Concat(output, "FacebookId: ", FacebookId, ", ");
            output = string.Concat(output, "FacebookInstantGameId: ", FacebookInstantGameId, ", ");
            output = string.Concat(output, "GamecenterId: ", GamecenterId, ", ");
            output = string.Concat(output, "GoogleId: ", GoogleId, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "LangTag: ", LangTag, ", ");
            output = string.Concat(output, "Location: ", Location, ", ");
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "Online: ", Online, ", ");
            output = string.Concat(output, "SteamId: ", SteamId, ", ");
            output = string.Concat(output, "Timezone: ", Timezone, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// Account information.
    /// </summary>
    public interface INakamaconsoleAccount
    {

        /// <summary>
        /// The user's account details.
        /// </summary>
        INakamaapiAccount Account { get; }

        /// <summary>
        /// The UNIX time when the account was disabled.
        /// </summary>
        string DisableTime { get; }
    }

    /// <inheritdoc />
    internal class NakamaconsoleAccount : INakamaconsoleAccount
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public INakamaapiAccount Account => _account;
        [DataMember(Name="account"), Preserve]
        public NakamaapiAccount _account { get; set; }

        /// <inheritdoc />
        [DataMember(Name="disable_time"), Preserve]
        public string DisableTime { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Account: ", Account, ", ");
            output = string.Concat(output, "DisableTime: ", DisableTime, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of groups.
    /// </summary>
    public interface INakamaconsoleGroupList
    {

        /// <summary>
        /// A list of groups.
        /// </summary>
        IEnumerable<IApiGroup> Groups { get; }

        /// <summary>
        /// Next cursor.
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// Approximate total number of groups.
        /// </summary>
        int TotalCount { get; }
    }

    /// <inheritdoc />
    internal class NakamaconsoleGroupList : INakamaconsoleGroupList
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IApiGroup> Groups => _groups ?? new List<ApiGroup>(0);
        [DataMember(Name="groups"), Preserve]
        public List<ApiGroup> _groups { get; set; }

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        [DataMember(Name="total_count"), Preserve]
        public int TotalCount { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Groups: [", string.Join(", ", Groups), "], ");
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "TotalCount: ", TotalCount, ", ");
            return output;
        }
    }

    /// <summary>
    /// A leaderboard.
    /// </summary>
    public interface INakamaconsoleLeaderboard
    {

        /// <summary>
        /// Authoritative.
        /// </summary>
        bool Authoritative { get; }

        /// <summary>
        /// The category of the leaderboard. e.g. "vip" could be category 1.
        /// </summary>
        int Category { get; }

        /// <summary>
        /// The UNIX time when the leaderboard was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The description of the leaderboard. May be blank.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// Duration of the tournament in seconds.
        /// </summary>
        int Duration { get; }

        /// <summary>
        /// The UNIX time when the leaderboard stops being active until next reset. A computed value.
        /// </summary>
        int EndActive { get; }

        /// <summary>
        /// The UNIX time when the leaderboard will be stopped.
        /// </summary>
        string EndTime { get; }

        /// <summary>
        /// The ID of the leaderboard.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// Join required.
        /// </summary>
        bool JoinRequired { get; }

        /// <summary>
        /// The maximum score updates allowed per player for the current leaderboard.
        /// </summary>
        int MaxNumScore { get; }

        /// <summary>
        /// The maximum number of players for the leaderboard.
        /// </summary>
        int MaxSize { get; }

        /// <summary>
        /// Additional information stored as a JSON object.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The UNIX time when the tournament is next playable. A computed value.
        /// </summary>
        int NextReset { get; }

        /// <summary>
        /// The operator of the leaderboard
        /// </summary>
        int Operator { get; }

        /// <summary>
        /// The UNIX time when the tournament was last reset. A computed value.
        /// </summary>
        int PrevReset { get; }

        /// <summary>
        /// Reset cron expression.
        /// </summary>
        string ResetSchedule { get; }

        /// <summary>
        /// The current number of players in the leaderboard.
        /// </summary>
        int Size { get; }

        /// <summary>
        /// ASC or DESC sort mode of scores in the leaderboard.
        /// </summary>
        int SortOrder { get; }

        /// <summary>
        /// The UNIX time when the leaderboard start being active. A computed value.
        /// </summary>
        int StartActive { get; }

        /// <summary>
        /// The UNIX time when the leaderboard will start.
        /// </summary>
        string StartTime { get; }

        /// <summary>
        /// The title for the leaderboard.
        /// </summary>
        string Title { get; }

        /// <summary>
        /// Tournament.
        /// </summary>
        bool Tournament { get; }
    }

    /// <inheritdoc />
    internal class NakamaconsoleLeaderboard : INakamaconsoleLeaderboard
    {

        /// <inheritdoc />
        [DataMember(Name="authoritative"), Preserve]
        public bool Authoritative { get; set; }

        /// <inheritdoc />
        [DataMember(Name="category"), Preserve]
        public int Category { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="description"), Preserve]
        public string Description { get; set; }

        /// <inheritdoc />
        [DataMember(Name="duration"), Preserve]
        public int Duration { get; set; }

        /// <inheritdoc />
        [DataMember(Name="end_active"), Preserve]
        public int EndActive { get; set; }

        /// <inheritdoc />
        [DataMember(Name="end_time"), Preserve]
        public string EndTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="join_required"), Preserve]
        public bool JoinRequired { get; set; }

        /// <inheritdoc />
        [DataMember(Name="max_num_score"), Preserve]
        public int MaxNumScore { get; set; }

        /// <inheritdoc />
        [DataMember(Name="max_size"), Preserve]
        public int MaxSize { get; set; }

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="next_reset"), Preserve]
        public int NextReset { get; set; }

        /// <inheritdoc />
        [DataMember(Name="operator"), Preserve]
        public int Operator { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_reset"), Preserve]
        public int PrevReset { get; set; }

        /// <inheritdoc />
        [DataMember(Name="reset_schedule"), Preserve]
        public string ResetSchedule { get; set; }

        /// <inheritdoc />
        [DataMember(Name="size"), Preserve]
        public int Size { get; set; }

        /// <inheritdoc />
        [DataMember(Name="sort_order"), Preserve]
        public int SortOrder { get; set; }

        /// <inheritdoc />
        [DataMember(Name="start_active"), Preserve]
        public int StartActive { get; set; }

        /// <inheritdoc />
        [DataMember(Name="start_time"), Preserve]
        public string StartTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="title"), Preserve]
        public string Title { get; set; }

        /// <inheritdoc />
        [DataMember(Name="tournament"), Preserve]
        public bool Tournament { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Authoritative: ", Authoritative, ", ");
            output = string.Concat(output, "Category: ", Category, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Description: ", Description, ", ");
            output = string.Concat(output, "Duration: ", Duration, ", ");
            output = string.Concat(output, "EndActive: ", EndActive, ", ");
            output = string.Concat(output, "EndTime: ", EndTime, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "JoinRequired: ", JoinRequired, ", ");
            output = string.Concat(output, "MaxNumScore: ", MaxNumScore, ", ");
            output = string.Concat(output, "MaxSize: ", MaxSize, ", ");
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "NextReset: ", NextReset, ", ");
            output = string.Concat(output, "Operator: ", Operator, ", ");
            output = string.Concat(output, "PrevReset: ", PrevReset, ", ");
            output = string.Concat(output, "ResetSchedule: ", ResetSchedule, ", ");
            output = string.Concat(output, "Size: ", Size, ", ");
            output = string.Concat(output, "SortOrder: ", SortOrder, ", ");
            output = string.Concat(output, "StartActive: ", StartActive, ", ");
            output = string.Concat(output, "StartTime: ", StartTime, ", ");
            output = string.Concat(output, "Title: ", Title, ", ");
            output = string.Concat(output, "Tournament: ", Tournament, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of leaderboards.
    /// </summary>
    public interface INakamaconsoleLeaderboardList
    {

        /// <summary>
        /// A cursor, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// The list of leaderboards returned.
        /// </summary>
        IEnumerable<INakamaconsoleLeaderboard> Leaderboards { get; }

        /// <summary>
        /// Total count of leaderboards and tournaments.
        /// </summary>
        int Total { get; }
    }

    /// <inheritdoc />
    internal class NakamaconsoleLeaderboardList : INakamaconsoleLeaderboardList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<INakamaconsoleLeaderboard> Leaderboards => _leaderboards ?? new List<NakamaconsoleLeaderboard>(0);
        [DataMember(Name="leaderboards"), Preserve]
        public List<NakamaconsoleLeaderboard> _leaderboards { get; set; }

        /// <inheritdoc />
        [DataMember(Name="total"), Preserve]
        public int Total { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "Leaderboards: [", string.Join(", ", Leaderboards), "], ");
            output = string.Concat(output, "Total: ", Total, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of realtime matches, with their node names.
    /// </summary>
    public interface INakamaconsoleMatchList
    {

        /// <summary>
        /// 
        /// </summary>
        IEnumerable<IConsoleMatchListMatch> Matches { get; }
    }

    /// <inheritdoc />
    internal class NakamaconsoleMatchList : INakamaconsoleMatchList
    {

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<IConsoleMatchListMatch> Matches => _matches ?? new List<ConsoleMatchListMatch>(0);
        [DataMember(Name="matches"), Preserve]
        public List<ConsoleMatchListMatch> _matches { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Matches: [", string.Join(", ", Matches), "], ");
            return output;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public interface INakamaconsoleNotification
    {

        /// <summary>
        /// Category code for this notification.
        /// </summary>
        int Code { get; }

        /// <summary>
        /// Content of the notification in JSON.
        /// </summary>
        string Content { get; }

        /// <summary>
        /// The UNIX time (for gRPC clients) or ISO string (for REST clients) when the notification was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// ID of the Notification.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// True if this notification was persisted to the database.
        /// </summary>
        bool Persistent { get; }

        /// <summary>
        /// ID of the sender, if a user. Otherwise 'null'.
        /// </summary>
        string SenderId { get; }

        /// <summary>
        /// Subject of the notification.
        /// </summary>
        string Subject { get; }

        /// <summary>
        /// User id.
        /// </summary>
        string UserId { get; }
    }

    /// <inheritdoc />
    internal class NakamaconsoleNotification : INakamaconsoleNotification
    {

        /// <inheritdoc />
        [DataMember(Name="code"), Preserve]
        public int Code { get; set; }

        /// <inheritdoc />
        [DataMember(Name="content"), Preserve]
        public string Content { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="persistent"), Preserve]
        public bool Persistent { get; set; }

        /// <inheritdoc />
        [DataMember(Name="sender_id"), Preserve]
        public string SenderId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="subject"), Preserve]
        public string Subject { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Code: ", Code, ", ");
            output = string.Concat(output, "Content: ", Content, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "Persistent: ", Persistent, ", ");
            output = string.Concat(output, "SenderId: ", SenderId, ", ");
            output = string.Concat(output, "Subject: ", Subject, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            return output;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public interface INakamaconsoleNotificationList
    {

        /// <summary>
        /// Next page cursor if any.
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// List of notifications.
        /// </summary>
        IEnumerable<INakamaconsoleNotification> Notifications { get; }

        /// <summary>
        /// Previous page cursor if any.
        /// </summary>
        string PrevCursor { get; }
    }

    /// <inheritdoc />
    internal class NakamaconsoleNotificationList : INakamaconsoleNotificationList
    {

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        [IgnoreDataMember]
        public IEnumerable<INakamaconsoleNotification> Notifications => _notifications ?? new List<NakamaconsoleNotification>(0);
        [DataMember(Name="notifications"), Preserve]
        public List<NakamaconsoleNotification> _notifications { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_cursor"), Preserve]
        public string PrevCursor { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "Notifications: [", string.Join(", ", Notifications), "], ");
            output = string.Concat(output, "PrevCursor: ", PrevCursor, ", ");
            return output;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public interface IProtobufAny
    {

        /// <summary>
        /// 
        /// </summary>
        string @type { get; }
    }

    /// <inheritdoc />
    internal class ProtobufAny : IProtobufAny
    {

        /// <inheritdoc />
        [DataMember(Name="@type"), Preserve]
        public string @type { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "@type: ", @type, ", ");
            return output;
        }
    }

    /// <summary>
    /// A user session associated to a stream, usually through a list operation or a join/leave event.
    /// </summary>
    public interface IRealtimeUserPresence
    {

        /// <summary>
        /// Whether this presence generates persistent data/messages, if applicable for the stream type.
        /// </summary>
        bool Persistence { get; }

        /// <summary>
        /// A unique session ID identifying the particular connection, because the user may have many.
        /// </summary>
        string SessionId { get; }

        /// <summary>
        /// A user-set status message for this stream, if applicable.
        /// </summary>
        string Status { get; }

        /// <summary>
        /// The user this presence belongs to.
        /// </summary>
        string UserId { get; }

        /// <summary>
        /// The username for display purposes.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class RealtimeUserPresence : IRealtimeUserPresence
    {

        /// <inheritdoc />
        [DataMember(Name="persistence"), Preserve]
        public bool Persistence { get; set; }

        /// <inheritdoc />
        [DataMember(Name="session_id"), Preserve]
        public string SessionId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="status"), Preserve]
        public string Status { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Persistence: ", Persistence, ", ");
            output = string.Concat(output, "SessionId: ", SessionId, ", ");
            output = string.Concat(output, "Status: ", Status, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// The low level client for the Nakama.Console API.
    /// </summary>
    internal class ApiClient
    {
        public readonly IHttpAdapter HttpAdapter;
        public int Timeout { get; set; }

        private readonly Uri _baseUri;

        public ApiClient(Uri baseUri, IHttpAdapter httpAdapter, int timeout = 10)
        {
            _baseUri = baseUri;
            HttpAdapter = httpAdapter;
            Timeout = timeout;
        }

        /// <summary>
        /// Delete (non-recorded) all user accounts.
        /// </summary>
        public async Task ConsoleDeleteAccountsAsync(
            string bearerToken,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/account";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// List (and optionally filter) accounts.
        /// </summary>
        public async Task<IConsoleAccountList> ConsoleListAccountsAsync(
            string bearerToken,
            string filter,
            bool? tombstones,
            string cursor,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/account";

            var queryParams = "";
            if (filter != null) {
                queryParams = string.Concat(queryParams, "filter=", Uri.EscapeDataString(filter), "&");
            }
            if (tombstones != null) {
                queryParams = string.Concat(queryParams, "tombstones=", tombstones.ToString().ToLower(), "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleAccountList>();
        }

        /// <summary>
        /// Get a list of the user's wallet transactions.
        /// </summary>
        public async Task<IConsoleWalletLedgerList> ConsoleGetWalletLedgerAsync(
            string bearerToken,
            string account_id,
            int? limit,
            string cursor,
            CancellationToken? cancellationToken)
        {
            if (accountId == null)
            {
                throw new ArgumentException("'accountId' is required but was null.");
            }

            var urlpath = "/v2/console/account/{account_id}/wallet";
            urlpath = urlpath.Replace("{account_id}", Uri.EscapeDataString(account_id));

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleWalletLedgerList>();
        }

        /// <summary>
        /// Delete all information stored for a user account.
        /// </summary>
        public async Task ConsoleDeleteAccountAsync(
            string bearerToken,
            string id,
            bool? record_deletion,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";
            if (record_deletion != null) {
                queryParams = string.Concat(queryParams, "record_deletion=", record_deletion.ToString().ToLower(), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Get detailed account information for a single user.
        /// </summary>
        public async Task<INakamaconsoleAccount> ConsoleGetAccountAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<NakamaconsoleAccount>();
        }

        /// <summary>
        /// Update one or more fields on a user account.
        /// </summary>
        public async Task ConsoleUpdateAccountAsync(
            string bearerToken,
            string id,
             body,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Ban a user.
        /// </summary>
        public async Task ConsoleBanAccountAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/ban";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Export all information stored about a user account.
        /// </summary>
        public async Task<IConsoleAccountExport> ConsoleExportAccountAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/export";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleAccountExport>();
        }

        /// <summary>
        /// Get a user's list of friend relationships.
        /// </summary>
        public async Task<IApiFriendList> ConsoleGetFriendsAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/friend";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiFriendList>();
        }

        /// <summary>
        /// Delete the friend relationship between two users.
        /// </summary>
        public async Task ConsoleDeleteFriendAsync(
            string bearerToken,
            string id,
            string friend_id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }
            if (friendId == null)
            {
                throw new ArgumentException("'friendId' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/friend/{friend_id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));
            urlpath = urlpath.Replace("{friend_id}", Uri.EscapeDataString(friend_id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Get a list of groups the user is a member of.
        /// </summary>
        public async Task<IApiUserGroupList> ConsoleGetGroupsAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/group";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiUserGroupList>();
        }

        /// <summary>
        /// Remove a user from a group.
        /// </summary>
        public async Task ConsoleDeleteGroupUserAsync(
            string bearerToken,
            string id,
            string group_id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/group/{group_id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unban a user.
        /// </summary>
        public async Task ConsoleUnbanAccountAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unban";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unlink the Apple ID from a user account.
        /// </summary>
        public async Task ConsoleUnlinkAppleAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unlink/apple";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unlink the custom ID from a user account.
        /// </summary>
        public async Task ConsoleUnlinkCustomAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unlink/custom";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unlink the device ID from a user account.
        /// </summary>
        public async Task ConsoleUnlinkDeviceAsync(
            string bearerToken,
            string id,
             body,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unlink/device";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unlink the email from a user account.
        /// </summary>
        public async Task ConsoleUnlinkEmailAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unlink/email";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unlink the Facebook ID from a user account.
        /// </summary>
        public async Task ConsoleUnlinkFacebookAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unlink/facebook";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unlink the Facebook Instant Game ID from a user account.
        /// </summary>
        public async Task ConsoleUnlinkFacebookInstantGameAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unlink/facebookinstantgame";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unlink the Game Center ID from a user account.
        /// </summary>
        public async Task ConsoleUnlinkGameCenterAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unlink/gamecenter";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unlink the Google ID from a user account.
        /// </summary>
        public async Task ConsoleUnlinkGoogleAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unlink/google";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Unlink the Steam ID from a user account.
        /// </summary>
        public async Task ConsoleUnlinkSteamAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/unlink/steam";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Delete a wallet ledger item.
        /// </summary>
        public async Task ConsoleDeleteWalletLedgerAsync(
            string bearerToken,
            string id,
            string wallet_id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }
            if (walletId == null)
            {
                throw new ArgumentException("'walletId' is required but was null.");
            }

            var urlpath = "/v2/console/account/{id}/wallet/{wallet_id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));
            urlpath = urlpath.Replace("{wallet_id}", Uri.EscapeDataString(wallet_id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Deletes all data
        /// </summary>
        public async Task ConsoleDeleteAllDataAsync(
            string bearerToken,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/all";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// API Explorer - list all endpoints
        /// </summary>
        public async Task<IConsoleApiEndpointList> ConsoleListApiEndpointsAsync(
            string bearerToken,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/api/endpoints";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleApiEndpointList>();
        }

        /// <summary>
        /// API Explorer - call a custom RPC endpoint
        /// </summary>
        public async Task<IConsoleCallApiEndpointResponse> ConsoleCallRpcEndpointAsync(
            string bearerToken,
            string method,
             body,
            CancellationToken? cancellationToken)
        {
            if (method == null)
            {
                throw new ArgumentException("'method' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/api/endpoints/rpc/{method}";
            urlpath = urlpath.Replace("{method}", Uri.EscapeDataString(method));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleCallApiEndpointResponse>();
        }

        /// <summary>
        /// API Explorer - call an endpoint
        /// </summary>
        public async Task<IConsoleCallApiEndpointResponse> ConsoleCallApiEndpointAsync(
            string bearerToken,
            string method,
             body,
            CancellationToken? cancellationToken)
        {
            if (method == null)
            {
                throw new ArgumentException("'method' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/api/endpoints/{method}";
            urlpath = urlpath.Replace("{method}", Uri.EscapeDataString(method));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleCallApiEndpointResponse>();
        }

        /// <summary>
        /// Authenticate a console user with username and password.
        /// </summary>
        public async Task<IConsoleConsoleSession> ConsoleAuthenticateAsync(
            ConsoleAuthenticateRequest body,
            CancellationToken? cancellationToken)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/authenticate";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleConsoleSession>();
        }

        /// <summary>
        /// Log out a session and invalidate the session token.
        /// </summary>
        public async Task ConsoleAuthenticateLogoutAsync(
            string bearerToken,
            ConsoleAuthenticateLogoutRequest body,
            CancellationToken? cancellationToken)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/authenticate/logout";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Change an account's MFA using a code, usually delivered over email.
        /// </summary>
        public async Task<IConsoleAuthenticateMFASetupResponse> ConsoleAuthenticateMFASetupAsync(
            string bearerToken,
            ConsoleAuthenticateMFASetupRequest body,
            CancellationToken? cancellationToken)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/authenticate/mfa";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleAuthenticateMFASetupResponse>();
        }

        /// <summary>
        /// List channel messages with the selected filter
        /// </summary>
        public async Task<IApiChannelMessageList> ConsoleListChannelMessagesAsync(
            string bearerToken,
            string type,
            string label,
            string group_id,
            string user_id_one,
            string user_id_two,
            string cursor,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/channel";

            var queryParams = "";
            if (type != null) {
                queryParams = string.Concat(queryParams, "type=", Uri.EscapeDataString(type), "&");
            }
            if (label != null) {
                queryParams = string.Concat(queryParams, "label=", Uri.EscapeDataString(label), "&");
            }
            if (group_id != null) {
                queryParams = string.Concat(queryParams, "group_id=", Uri.EscapeDataString(group_id), "&");
            }
            if (user_id_one != null) {
                queryParams = string.Concat(queryParams, "user_id_one=", Uri.EscapeDataString(user_id_one), "&");
            }
            if (user_id_two != null) {
                queryParams = string.Concat(queryParams, "user_id_two=", Uri.EscapeDataString(user_id_two), "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiChannelMessageList>();
        }

        /// <summary>
        /// Get server config and configuration warnings.
        /// </summary>
        public async Task<IConsoleConfig> ConsoleGetConfigAsync(
            string bearerToken,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/config";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleConfig>();
        }

        /// <summary>
        /// List (and optionally filter) groups.
        /// </summary>
        public async Task<INakamaconsoleGroupList> ConsoleListGroupsAsync(
            string bearerToken,
            string filter,
            string cursor,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/group";

            var queryParams = "";
            if (filter != null) {
                queryParams = string.Concat(queryParams, "filter=", Uri.EscapeDataString(filter), "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<NakamaconsoleGroupList>();
        }

        /// <summary>
        /// Demote a user from a group.
        /// </summary>
        public async Task ConsoleDemoteGroupMemberAsync(
            string bearerToken,
            string group_id,
            string id,
            CancellationToken? cancellationToken)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/group/{group_id}/account/{id}/demote";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Promote a user from a group.
        /// </summary>
        public async Task ConsolePromoteGroupMemberAsync(
            string bearerToken,
            string group_id,
            string id,
            CancellationToken? cancellationToken)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/group/{group_id}/account/{id}/promote";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Add/join members to a group.
        /// </summary>
        public async Task ConsoleAddGroupUsersAsync(
            string bearerToken,
            string group_id,
             body,
            CancellationToken? cancellationToken)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/group/{group_id}/add";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Remove a group.
        /// </summary>
        public async Task ConsoleDeleteGroupAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/group/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Get detailed group information.
        /// </summary>
        public async Task<IApiGroup> ConsoleGetGroupAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/group/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiGroup>();
        }

        /// <summary>
        /// Update one or more fields on a group.
        /// </summary>
        public async Task ConsoleUpdateGroupAsync(
            string bearerToken,
            string id,
             body,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/group/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Export all information stored about a group.
        /// </summary>
        public async Task<IConsoleGroupExport> ConsoleExportGroupAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/group/{id}/export";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleGroupExport>();
        }

        /// <summary>
        /// Get a list of members of the group.
        /// </summary>
        public async Task<IApiGroupUserList> ConsoleGetMembersAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/group/{id}/member";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiGroupUserList>();
        }

        /// <summary>
        /// Get purchase by transaction_id
        /// </summary>
        public async Task<IApiValidatedPurchase> ConsoleGetPurchaseAsync(
            string bearerToken,
            string transaction_id,
            CancellationToken? cancellationToken)
        {
            if (transactionId == null)
            {
                throw new ArgumentException("'transactionId' is required but was null.");
            }

            var urlpath = "/v2/console/iap/purchase/{transaction_id}";
            urlpath = urlpath.Replace("{transaction_id}", Uri.EscapeDataString(transaction_id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiValidatedPurchase>();
        }

        /// <summary>
        /// Get subscription by original_transaction_id
        /// </summary>
        public async Task<IApiValidatedSubscription> ConsoleGetSubscriptionAsync(
            string bearerToken,
            string original_transaction_id,
            CancellationToken? cancellationToken)
        {
            if (originalTransactionId == null)
            {
                throw new ArgumentException("'originalTransactionId' is required but was null.");
            }

            var urlpath = "/v2/console/iap/subscription/{original_transaction_id}";
            urlpath = urlpath.Replace("{original_transaction_id}", Uri.EscapeDataString(original_transaction_id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiValidatedSubscription>();
        }

        /// <summary>
        /// List leaderboards
        /// </summary>
        public async Task<INakamaconsoleLeaderboardList> ConsoleListLeaderboardsAsync(
            string bearerToken,
            string cursor,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/leaderboard";

            var queryParams = "";
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<NakamaconsoleLeaderboardList>();
        }

        /// <summary>
        /// Delete leaderboard
        /// </summary>
        public async Task ConsoleDeleteLeaderboardAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/leaderboard/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Get leaderboard.
        /// </summary>
        public async Task<INakamaconsoleLeaderboard> ConsoleGetLeaderboardAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/leaderboard/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<NakamaconsoleLeaderboard>();
        }

        /// <summary>
        /// Delete leaderboard record
        /// </summary>
        public async Task ConsoleDeleteLeaderboardRecordAsync(
            string bearerToken,
            string id,
            string owner_id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }
            if (ownerId == null)
            {
                throw new ArgumentException("'ownerId' is required but was null.");
            }

            var urlpath = "/v2/console/leaderboard/{id}/owner/{owner_id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));
            urlpath = urlpath.Replace("{owner_id}", Uri.EscapeDataString(owner_id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// List leaderboard records.
        /// </summary>
        public async Task<IApiLeaderboardRecordList> ConsoleListLeaderboardRecordsAsync(
            string bearerToken,
            string leaderboard_id,
            IEnumerable<string> ownerIds,
            int? limit,
            string cursor,
            string expiry,
            CancellationToken? cancellationToken)
        {
            if (leaderboardId == null)
            {
                throw new ArgumentException("'leaderboardId' is required but was null.");
            }

            var urlpath = "/v2/console/leaderboard/{leaderboard_id}/records";
            urlpath = urlpath.Replace("{leaderboard_id}", Uri.EscapeDataString(leaderboard_id));

            var queryParams = "";
            foreach (var elem in ownerIds ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "owner_ids=", Uri.EscapeDataString(elem), "&");
            }
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }
            if (expiry != null) {
                queryParams = string.Concat(queryParams, "expiry=", Uri.EscapeDataString(expiry), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiLeaderboardRecordList>();
        }

        /// <summary>
        /// List ongoing matches
        /// </summary>
        public async Task<INakamaconsoleMatchList> ConsoleListMatchesAsync(
            string bearerToken,
            int? limit,
            bool? authoritative,
            string label,
            int? min_size,
            int? max_size,
            string match_id,
            string query,
            string node,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/match";

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (authoritative != null) {
                queryParams = string.Concat(queryParams, "authoritative=", authoritative.ToString().ToLower(), "&");
            }
            if (label != null) {
                queryParams = string.Concat(queryParams, "label=", Uri.EscapeDataString(label), "&");
            }
            if (min_size != null) {
                queryParams = string.Concat(queryParams, "min_size=", min_size, "&");
            }
            if (max_size != null) {
                queryParams = string.Concat(queryParams, "max_size=", max_size, "&");
            }
            if (match_id != null) {
                queryParams = string.Concat(queryParams, "match_id=", Uri.EscapeDataString(match_id), "&");
            }
            if (query != null) {
                queryParams = string.Concat(queryParams, "query=", Uri.EscapeDataString(query), "&");
            }
            if (node != null) {
                queryParams = string.Concat(queryParams, "node=", Uri.EscapeDataString(node), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<NakamaconsoleMatchList>();
        }

        /// <summary>
        /// Get current state of a running match
        /// </summary>
        public async Task<IConsoleMatchState> ConsoleGetMatchStateAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/match/{id}/state";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleMatchState>();
        }

        /// <summary>
        /// Delete messages.
        /// </summary>
        public async Task<IConsoleDeleteChannelMessagesResponse> ConsoleDeleteChannelMessagesAsync(
            string bearerToken,
            string before,
            IEnumerable<string> ids,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/message";

            var queryParams = "";
            if (before != null) {
                queryParams = string.Concat(queryParams, "before=", Uri.EscapeDataString(before), "&");
            }
            foreach (var elem in ids ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "ids=", Uri.EscapeDataString(elem), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleDeleteChannelMessagesResponse>();
        }

        /// <summary>
        /// List notifications.
        /// </summary>
        public async Task<INakamaconsoleNotificationList> ConsoleListNotificationsAsync(
            string bearerToken,
            string user_id,
            int? limit,
            string cursor,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/notification";

            var queryParams = "";
            if (user_id != null) {
                queryParams = string.Concat(queryParams, "user_id=", Uri.EscapeDataString(user_id), "&");
            }
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<NakamaconsoleNotificationList>();
        }

        /// <summary>
        /// Delete notification
        /// </summary>
        public async Task ConsoleDeleteNotificationAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/notification/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Get a notification by id.
        /// </summary>
        public async Task<INakamaconsoleNotification> ConsoleGetNotificationAsync(
            string bearerToken,
            string id,
            CancellationToken? cancellationToken)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/console/notification/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<NakamaconsoleNotification>();
        }

        /// <summary>
        /// List validated purchases
        /// </summary>
        public async Task<IApiPurchaseList> ConsoleListPurchasesAsync(
            string bearerToken,
            string user_id,
            int? limit,
            string cursor,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/purchase";

            var queryParams = "";
            if (user_id != null) {
                queryParams = string.Concat(queryParams, "user_id=", Uri.EscapeDataString(user_id), "&");
            }
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiPurchaseList>();
        }

        /// <summary>
        /// Get runtime info
        /// </summary>
        public async Task<IConsoleRuntimeInfo> ConsoleGetRuntimeAsync(
            string bearerToken,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/runtime";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleRuntimeInfo>();
        }

        /// <summary>
        /// List settings
        /// </summary>
        public async Task<IConsoleSettingList> ConsoleListSettingsAsync(
            string bearerToken,
            IEnumerable<string> names,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/setting";

            var queryParams = "";
            foreach (var elem in names ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "names=", Uri.EscapeDataString(elem), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleSettingList>();
        }

        /// <summary>
        /// Get console settings.
        /// </summary>
        public async Task<IConsoleSetting> ConsoleGetSettingAsync(
            string bearerToken,
            string name,
            CancellationToken? cancellationToken)
        {
            if (name == null)
            {
                throw new ArgumentException("'name' is required but was null.");
            }

            var urlpath = "/v2/console/setting/{name}";
            urlpath = urlpath.Replace("{name}", Uri.EscapeDataString(name));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleSetting>();
        }

        /// <summary>
        /// Update an existing setting.
        /// </summary>
        public async Task<IConsoleSetting> ConsoleUpdateSettingAsync(
            string bearerToken,
            string name,
             body,
            CancellationToken? cancellationToken)
        {
            if (name == null)
            {
                throw new ArgumentException("'name' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/setting/{name}";
            urlpath = urlpath.Replace("{name}", Uri.EscapeDataString(name));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleSetting>();
        }

        /// <summary>
        /// Get current status data for all nodes.
        /// </summary>
        public async Task<IConsoleStatusList> ConsoleGetStatusAsync(
            string bearerToken,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/status";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleStatusList>();
        }

        /// <summary>
        /// Delete all storage data.
        /// </summary>
        public async Task ConsoleDeleteStorageAsync(
            string bearerToken,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/storage";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// List (and optionally filter) storage data.
        /// </summary>
        public async Task<IConsoleStorageList> ConsoleListStorageAsync(
            string bearerToken,
            string user_id,
            string key,
            string collection,
            string cursor,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/storage";

            var queryParams = "";
            if (user_id != null) {
                queryParams = string.Concat(queryParams, "user_id=", Uri.EscapeDataString(user_id), "&");
            }
            if (key != null) {
                queryParams = string.Concat(queryParams, "key=", Uri.EscapeDataString(key), "&");
            }
            if (collection != null) {
                queryParams = string.Concat(queryParams, "collection=", Uri.EscapeDataString(collection), "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleStorageList>();
        }

        /// <summary>
        /// List storage collections
        /// </summary>
        public async Task<IConsoleStorageCollectionsList> ConsoleListStorageCollectionsAsync(
            string bearerToken,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/storage/collections";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleStorageCollectionsList>();
        }

        /// <summary>
        /// Delete a storage object.
        /// </summary>
        public async Task ConsoleDeleteStorageObjectAsync(
            string bearerToken,
            string collection,
            string key,
            string user_id,
            string version,
            CancellationToken? cancellationToken)
        {
            if (collection == null)
            {
                throw new ArgumentException("'collection' is required but was null.");
            }
            if (key == null)
            {
                throw new ArgumentException("'key' is required but was null.");
            }
            if (userId == null)
            {
                throw new ArgumentException("'userId' is required but was null.");
            }

            var urlpath = "/v2/console/storage/{collection}/{key}/{user_id}";
            urlpath = urlpath.Replace("{collection}", Uri.EscapeDataString(collection));
            urlpath = urlpath.Replace("{key}", Uri.EscapeDataString(key));
            urlpath = urlpath.Replace("{user_id}", Uri.EscapeDataString(user_id));

            var queryParams = "";
            if (version != null) {
                queryParams = string.Concat(queryParams, "version=", Uri.EscapeDataString(version), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Get a storage object.
        /// </summary>
        public async Task<IApiStorageObject> ConsoleGetStorageAsync(
            string bearerToken,
            string collection,
            string key,
            string user_id,
            CancellationToken? cancellationToken)
        {
            if (collection == null)
            {
                throw new ArgumentException("'collection' is required but was null.");
            }
            if (key == null)
            {
                throw new ArgumentException("'key' is required but was null.");
            }
            if (userId == null)
            {
                throw new ArgumentException("'userId' is required but was null.");
            }

            var urlpath = "/v2/console/storage/{collection}/{key}/{user_id}";
            urlpath = urlpath.Replace("{collection}", Uri.EscapeDataString(collection));
            urlpath = urlpath.Replace("{key}", Uri.EscapeDataString(key));
            urlpath = urlpath.Replace("{user_id}", Uri.EscapeDataString(user_id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiStorageObject>();
        }

        /// <summary>
        /// Write a new storage object or replace an existing one.
        /// </summary>
        public async Task<IApiStorageObjectAck> ConsoleWriteStorageObjectAsync(
            string bearerToken,
            string collection,
            string key,
            string user_id,
            ApiConsole_WriteStorageObjectRequest body,
            CancellationToken? cancellationToken)
        {
            if (collection == null)
            {
                throw new ArgumentException("'collection' is required but was null.");
            }
            if (key == null)
            {
                throw new ArgumentException("'key' is required but was null.");
            }
            if (userId == null)
            {
                throw new ArgumentException("'userId' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/storage/{collection}/{key}/{user_id}";
            urlpath = urlpath.Replace("{collection}", Uri.EscapeDataString(collection));
            urlpath = urlpath.Replace("{key}", Uri.EscapeDataString(key));
            urlpath = urlpath.Replace("{user_id}", Uri.EscapeDataString(user_id));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "PUT";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiStorageObjectAck>();
        }

        /// <summary>
        /// Delete a storage object.
        /// </summary>
        public async Task ConsoleDeleteStorageObject2Async(
            string bearerToken,
            string collection,
            string key,
            string user_id,
            string version,
            CancellationToken? cancellationToken)
        {
            if (collection == null)
            {
                throw new ArgumentException("'collection' is required but was null.");
            }
            if (key == null)
            {
                throw new ArgumentException("'key' is required but was null.");
            }
            if (userId == null)
            {
                throw new ArgumentException("'userId' is required but was null.");
            }
            if (version == null)
            {
                throw new ArgumentException("'version' is required but was null.");
            }

            var urlpath = "/v2/console/storage/{collection}/{key}/{user_id}/{version}";
            urlpath = urlpath.Replace("{collection}", Uri.EscapeDataString(collection));
            urlpath = urlpath.Replace("{key}", Uri.EscapeDataString(key));
            urlpath = urlpath.Replace("{user_id}", Uri.EscapeDataString(user_id));
            urlpath = urlpath.Replace("{version}", Uri.EscapeDataString(version));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// List validated subscriptions
        /// </summary>
        public async Task<IApiSubscriptionList> ConsoleListSubscriptionsAsync(
            string bearerToken,
            string user_id,
            int? limit,
            string cursor,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/subscription";

            var queryParams = "";
            if (user_id != null) {
                queryParams = string.Concat(queryParams, "user_id=", Uri.EscapeDataString(user_id), "&");
            }
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ApiSubscriptionList>();
        }

        /// <summary>
        /// Delete console user.
        /// </summary>
        public async Task ConsoleDeleteUserAsync(
            string bearerToken,
            string username,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/user";

            var queryParams = "";
            if (username != null) {
                queryParams = string.Concat(queryParams, "username=", Uri.EscapeDataString(username), "&");
            }

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// List (and optionally filter) users.
        /// </summary>
        public async Task<IConsoleUserList> ConsoleListUsersAsync(
            string bearerToken,
            CancellationToken? cancellationToken)
        {

            var urlpath = "/v2/console/user";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
            return contents.FromJson<ConsoleUserList>();
        }

        /// <summary>
        /// Add a new console user.
        /// </summary>
        public async Task ConsoleAddUserAsync(
            string bearerToken,
            ConsoleAddUserRequest body,
            CancellationToken? cancellationToken)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/user";

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Sets the user's MFA as required or not required.
        /// </summary>
        public async Task ConsoleRequireUserMfaAsync(
            string bearerToken,
            string username,
             body,
            CancellationToken? cancellationToken)
        {
            if (username == null)
            {
                throw new ArgumentException("'username' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/console/user/{username}/mfa/require";
            urlpath = urlpath.Replace("{username}", Uri.EscapeDataString(username));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }

        /// <summary>
        /// Reset a user's multi-factor authentication credentials.
        /// </summary>
        public async Task ConsoleResetUserMfaAsync(
            string bearerToken,
            string username,
            CancellationToken? cancellationToken)
        {
            if (username == null)
            {
                throw new ArgumentException("'username' is required but was null.");
            }

            var urlpath = "/v2/console/user/{username}/mfa/reset";
            urlpath = urlpath.Replace("{username}", Uri.EscapeDataString(username));

            var queryParams = "";

            string path = _baseUri.AbsolutePath.TrimEnd('/') + urlpath;

            var uri = new UriBuilder(_baseUri)
            {
                Path = path,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, Timeout, cancellationToken);
        }
    }
}
